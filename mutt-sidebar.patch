From f3e9205e821b71dfdec9b7208441e5bcf1185af0 Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Mon, 24 Oct 2011 16:32:35 +0200
Subject: [PATCH 01/19] applying debian/patches/mutt-patched/multiple-fcc

Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 protos.h  |    1 +
 send.c    |    2 +-
 sendlib.c |   30 ++++++++++++++++++++++++++++++
 3 files changed, 32 insertions(+), 1 deletions(-)

diff --git a/protos.h b/protos.h
index 140dfc3..12e4969 100644
--- a/protos.h
+++ b/protos.h
@@ -362,6 +362,7 @@ int mutt_user_is_recipient (HEADER *);
 void mutt_update_num_postponed (void);
 int mutt_wait_filter (pid_t);
 int mutt_which_case (const char *);
+int mutt_write_multiple_fcc (const char *path, HEADER *hdr, const char *msgid, int, char *);
 int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid, int, char *);
 int mutt_write_mime_body (BODY *, FILE *);
 int mutt_write_mime_header (BODY *, FILE *);
diff --git a/send.c b/send.c
index bc000a7..df65b13 100644
--- a/send.c
+++ b/send.c
@@ -1735,7 +1735,7 @@ full_fcc:
        * message was first postponed.
        */
       msg->received = time (NULL);
-      if (mutt_write_fcc (fcc, msg, NULL, 0, NULL) == -1)
+      if (mutt_write_multiple_fcc (fcc, msg, NULL, 0, NULL) == -1)
       {
 	/*
 	 * Error writing FCC, we should abort sending.
diff --git a/sendlib.c b/sendlib.c
index 8297ad5..c47039c 100644
--- a/sendlib.c
+++ b/sendlib.c
@@ -2664,6 +2664,36 @@ static void set_noconv_flags (BODY *b, short flag)
   }
 }
 
+/* Handle a Fcc with multiple, comma separated entries. */
+int mutt_write_multiple_fcc (const char *path, HEADER *hdr, const char *msgid, int post, char *fcc) {
+   char fcc_tok[_POSIX_PATH_MAX];
+   char fcc_expanded[_POSIX_PATH_MAX];
+   char *tok = NULL;
+   int status;
+
+  strfcpy(fcc_tok, path, _POSIX_PATH_MAX);
+
+   tok = strtok(fcc_tok, ",");
+   dprint(1, (debugfile, "Fcc: initial mailbox = '%s'\n", tok));
+   /* mutt_expand_path already called above for the first token */
+   if((status = mutt_write_fcc (tok, hdr, NULL, 0, NULL)) != 0)
+	  return status;
+
+   while((tok = strtok(NULL, ",")) != NULL) {
+	  if(*tok) {
+		 /* Only call mutt_expand_path iff tok has some data */
+		 dprint(1, (debugfile, "Fcc: additional mailbox token = '%s'\n", tok));
+		 strfcpy(fcc_expanded, tok, sizeof(fcc_expanded));
+		 mutt_expand_path(fcc_expanded, sizeof(fcc_expanded));
+		 dprint(1, (debugfile, "     Additional mailbox expanded = '%s'\n", fcc_expanded));
+		 if((status = mutt_write_fcc (fcc_expanded, hdr, NULL, 0, NULL)) != 0)
+			return status;
+	  }
+   }
+
+   return 0;
+}
+
 int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid, int post, char *fcc)
 {
   CONTEXT f;
-- 
1.7.7.3

From 29ea02764ad49ef0d6a6299766d29845eb1e1ba2 Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Mon, 24 Oct 2011 16:32:38 +0200
Subject: [PATCH 02/19] applying debian/patches/mutt-patched/sidebar

Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 Makefile.am    |    1 +
 OPS            |    5 +
 buffy.c        |   79 +++++++++++++
 buffy.h        |    4 +
 color.c        |    2 +
 compose.c      |   26 ++--
 curs_main.c    |   30 +++++-
 flags.c        |    3 +
 functions.h    |   10 ++
 globals.h      |    4 +
 imap/command.c |    7 +
 imap/imap.c    |    2 +-
 init.h         |   16 +++
 mailbox.h      |    1 +
 mbox.c         |    2 +
 menu.c         |   22 ++--
 mh.c           |   26 ++++-
 mutt.h         |    3 +
 mutt_curses.h  |    3 +
 muttlib.c      |   48 ++++++++
 mx.c           |   15 +++
 mx.h           |    1 +
 pager.c        |   30 ++++-
 sidebar.c      |  336 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 sidebar.h      |   36 ++++++
 25 files changed, 676 insertions(+), 36 deletions(-)
 create mode 100644 sidebar.c
 create mode 100644 sidebar.h

diff --git a/Makefile.am b/Makefile.am
index 0905a68..434f843 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -32,6 +32,7 @@ mutt_SOURCES = \
 	rfc822.c rfc1524.c rfc2047.c rfc2231.c rfc3676.c \
 	score.c send.c sendlib.c signal.c sort.c \
 	status.c system.c thread.c charset.c history.c lib.c \
+	sidebar.c \
 	muttlib.c editmsg.c mbyte.c \
 	url.c ascii.c crypt-mod.c crypt-mod.h safe_asprintf.c
 
diff --git a/OPS b/OPS
index 8414a8b..ef14453 100644
--- a/OPS
+++ b/OPS
@@ -179,3 +179,8 @@ OP_WHAT_KEY "display the keycode for a key press"
 OP_MAIN_SHOW_LIMIT "show currently active limit pattern"
 OP_MAIN_COLLAPSE_THREAD "collapse/uncollapse current thread"
 OP_MAIN_COLLAPSE_ALL "collapse/uncollapse all threads"
+OP_SIDEBAR_SCROLL_UP "scroll the mailbox pane up 1 page"
+OP_SIDEBAR_SCROLL_DOWN "scroll the mailbox pane down 1 page"
+OP_SIDEBAR_NEXT "go down to next mailbox"
+OP_SIDEBAR_PREV "go to previous mailbox"
+OP_SIDEBAR_OPEN "open hilighted mailbox"
diff --git a/buffy.c b/buffy.c
index fd54dd2..719e1c0 100644
--- a/buffy.c
+++ b/buffy.c
@@ -340,6 +340,68 @@ static int buffy_maildir_hasnew (BUFFY* mailbox)
   return rc;
 }
 
+/* update message counts for the sidebar */
+void buffy_maildir_update (BUFFY* mailbox)
+{
+  char path[_POSIX_PATH_MAX];
+  DIR *dirp;
+  struct dirent *de;
+  char *p;
+
+  mailbox->msgcount = 0;
+  mailbox->msg_unread = 0;
+  mailbox->msg_flagged = 0;
+
+  snprintf (path, sizeof (path), "%s/new", mailbox->path);
+        
+  if ((dirp = opendir (path)) == NULL)
+  {   
+    mailbox->magic = 0;
+    return;
+  } 
+      
+  while ((de = readdir (dirp)) != NULL)
+  {
+    if (*de->d_name == '.')
+      continue;
+
+    if (!(p = strstr (de->d_name, ":2,")) || !strchr (p + 3, 'T')) {
+      mailbox->new = 1;
+      mailbox->msgcount++;
+      mailbox->msg_unread++;
+    }
+  }
+
+  closedir (dirp);
+  snprintf (path, sizeof (path), "%s/cur", mailbox->path);
+        
+  if ((dirp = opendir (path)) == NULL)
+  {   
+    mailbox->magic = 0;
+    return;
+  } 
+      
+  while ((de = readdir (dirp)) != NULL)
+  {
+    if (*de->d_name == '.')
+      continue;
+
+    if (!(p = strstr (de->d_name, ":2,")) || !strchr (p + 3, 'T')) {
+      mailbox->msgcount++;
+      if ((p = strstr (de->d_name, ":2,"))) {
+        if (!strchr (p + 3, 'T')) {
+          if (!strchr (p + 3, 'S'))
+            mailbox->msg_unread++;
+          if (strchr(p + 3, 'F'))
+            mailbox->msg_flagged++;
+        }
+      }
+    }
+  }
+
+  closedir (dirp);
+}
+
 /* returns 1 if mailbox has new mail */ 
 static int buffy_mbox_hasnew (BUFFY* mailbox, struct stat *sb)
 {
@@ -371,6 +433,20 @@ static int buffy_mbox_hasnew (BUFFY* mailbox, struct stat *sb)
   return rc;
 }
 
+/* update message counts for the sidebar */
+void buffy_mbox_update (BUFFY* mailbox)
+{
+  CONTEXT *ctx = NULL;
+
+  ctx = mx_open_mailbox(mailbox->path, M_READONLY | M_QUIET | M_NOSORT | M_PEEK, NULL);
+  if(ctx)
+  {
+    mailbox->msgcount = ctx->msgcount;
+    mailbox->msg_unread = ctx->unread;
+    mx_close_mailbox(ctx, 0);
+  }
+}
+
 int mutt_buffy_check (int force)
 {
   BUFFY *tmp;
@@ -444,16 +520,19 @@ int mutt_buffy_check (int force)
       {
       case M_MBOX:
       case M_MMDF:
+	buffy_mbox_update (tmp);
 	if (buffy_mbox_hasnew (tmp, &sb) > 0)
 	  BuffyCount++;
 	break;
 
       case M_MAILDIR:
+	buffy_maildir_update (tmp);
 	if (buffy_maildir_hasnew (tmp) > 0)
 	  BuffyCount++;
 	break;
 
       case M_MH:
+	mh_buffy_update (tmp->path, &tmp->msgcount, &tmp->msg_unread, &tmp->msg_flagged);
 	if ((tmp->new = mh_buffy (tmp->path)) > 0)
 	  BuffyCount++;
 	break;
diff --git a/buffy.h b/buffy.h
index 2e5e048..7ad2ca2 100644
--- a/buffy.h
+++ b/buffy.h
@@ -25,7 +25,11 @@ typedef struct buffy_t
   char path[_POSIX_PATH_MAX];
   off_t size;
   struct buffy_t *next;
+  struct buffy_t *prev;
   short new;			/* mailbox has new mail */
+  int msgcount;			/* total number of messages */
+  int msg_unread;		/* number of unread messages */
+  int msg_flagged;		/* number of flagged messages */
   short notified;		/* user has been notified */
   short magic;			/* mailbox type */
   short newly_created;		/* mbox or mmdf just popped into existence */
diff --git a/color.c b/color.c
index b39957f..bb6cbb4 100644
--- a/color.c
+++ b/color.c
@@ -93,6 +93,8 @@ static struct mapping_t Fields[] =
   { "bold",		MT_COLOR_BOLD },
   { "underline",	MT_COLOR_UNDERLINE },
   { "index",		MT_COLOR_INDEX },
+  { "sidebar_new",	MT_COLOR_NEW },
+  { "sidebar_flagged",	MT_COLOR_FLAGGED },
   { NULL,		0 }
 };
 
diff --git a/compose.c b/compose.c
index c251d41..4c172de 100644
--- a/compose.c
+++ b/compose.c
@@ -72,7 +72,7 @@ enum
 
 #define HDR_XOFFSET 10
 #define TITLE_FMT "%10s" /* Used for Prompts, which are ASCII */
-#define W (COLS - HDR_XOFFSET)
+#define W (COLS - HDR_XOFFSET - SidebarWidth)
 
 static char *Prompts[] =
 {
@@ -112,7 +112,7 @@ static void redraw_crypt_lines (HEADER *msg)
 {
   int off = 0;
 
-  mvaddstr (HDR_CRYPT, 0, "Security: ");
+  mvaddstr (HDR_CRYPT, SidebarWidth, "Security: ");
 
   if ((WithCrypto & (APPLICATION_PGP | APPLICATION_SMIME)) == 0)
   {
@@ -144,7 +144,7 @@ static void redraw_crypt_lines (HEADER *msg)
   }
 
   clrtoeol ();
-  move (HDR_CRYPTINFO, 0);
+  move (HDR_CRYPTINFO, SidebarWidth);
   clrtoeol ();
 
   if ((WithCrypto & APPLICATION_PGP)
@@ -161,7 +161,7 @@ static void redraw_crypt_lines (HEADER *msg)
       && (msg->security & ENCRYPT)
       && SmimeCryptAlg
       && *SmimeCryptAlg) {
-      mvprintw (HDR_CRYPTINFO, 40, "%s%s", _("Encrypt with: "),
+      mvprintw (HDR_CRYPTINFO, SidebarWidth + 40, "%s%s", _("Encrypt with: "),
 		NONULL(SmimeCryptAlg));
       off = 20;
   }
@@ -175,7 +175,7 @@ static void redraw_mix_line (LIST *chain)
   int c;
   char *t;
 
-  mvaddstr (HDR_MIX, 0,     "     Mix: ");
+  mvaddstr (HDR_MIX, SidebarWidth,     "     Mix: ");
 
   if (!chain)
   {
@@ -190,7 +190,7 @@ static void redraw_mix_line (LIST *chain)
     if (t && t[0] == '0' && t[1] == '\0')
       t = "<random>";
     
-    if (c + mutt_strlen (t) + 2 >= COLS)
+    if (c + mutt_strlen (t) + 2 >= COLS - SidebarWidth)
       break;
 
     addstr (NONULL(t));
@@ -242,7 +242,7 @@ static void draw_envelope_addr (int line, ADDRESS *addr)
 
   buf[0] = 0;
   rfc822_write_address (buf, sizeof (buf), addr, 1);
-  mvprintw (line, 0, TITLE_FMT, Prompts[line - 1]);
+  mvprintw (line, SidebarWidth, TITLE_FMT, Prompts[line - 1]);
   mutt_paddstr (W, buf);
 }
 
@@ -252,10 +252,10 @@ static void draw_envelope (HEADER *msg, char *fcc)
   draw_envelope_addr (HDR_TO, msg->env->to);
   draw_envelope_addr (HDR_CC, msg->env->cc);
   draw_envelope_addr (HDR_BCC, msg->env->bcc);
-  mvprintw (HDR_SUBJECT, 0, TITLE_FMT, Prompts[HDR_SUBJECT - 1]);
+  mvprintw (HDR_SUBJECT, SidebarWidth, TITLE_FMT, Prompts[HDR_SUBJECT - 1]);
   mutt_paddstr (W, NONULL (msg->env->subject));
   draw_envelope_addr (HDR_REPLYTO, msg->env->reply_to);
-  mvprintw (HDR_FCC, 0, TITLE_FMT, Prompts[HDR_FCC - 1]);
+  mvprintw (HDR_FCC, SidebarWidth, TITLE_FMT, Prompts[HDR_FCC - 1]);
   mutt_paddstr (W, fcc);
 
   if (WithCrypto)
@@ -266,7 +266,7 @@ static void draw_envelope (HEADER *msg, char *fcc)
 #endif
 
   SETCOLOR (MT_COLOR_STATUS);
-  mvaddstr (HDR_ATTACH - 1, 0, _("-- Attachments"));
+  mvaddstr (HDR_ATTACH - 1, SidebarWidth, _("-- Attachments"));
   BKGDSET (MT_COLOR_STATUS);
   clrtoeol ();
 
@@ -304,7 +304,7 @@ static int edit_address_list (int line, ADDRESS **addr)
   /* redraw the expanded list so the user can see the result */
   buf[0] = 0;
   rfc822_write_address (buf, sizeof (buf), *addr, 1);
-  move (line, HDR_XOFFSET);
+  move (line, HDR_XOFFSET+SidebarWidth);
   mutt_paddstr (W, buf);
   
   return 0;
@@ -549,7 +549,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	if (mutt_get_field ("Subject: ", buf, sizeof (buf), 0) == 0)
 	{
 	  mutt_str_replace (&msg->env->subject, buf);
-	  move (HDR_SUBJECT, HDR_XOFFSET);
+	  move (HDR_SUBJECT, HDR_XOFFSET + SidebarWidth);
 	  clrtoeol ();
 	  if (msg->env->subject)
 	    mutt_paddstr (W, msg->env->subject);
@@ -566,7 +566,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	{
 	  strfcpy (fcc, buf, fcclen);
 	  mutt_pretty_mailbox (fcc, fcclen);
-	  move (HDR_FCC, HDR_XOFFSET);
+	  move (HDR_FCC, HDR_XOFFSET + SidebarWidth);
 	  mutt_paddstr (W, fcc);
 	  fccSet = 1;
 	}
diff --git a/curs_main.c b/curs_main.c
index dd2ac39..cd8b0a7 100644
--- a/curs_main.c
+++ b/curs_main.c
@@ -26,7 +26,9 @@
 #include "mailbox.h"
 #include "mapping.h"
 #include "sort.h"
+#include "buffy.h"
 #include "mx.h"
+#include "sidebar.h"
 
 #ifdef USE_POP
 #include "pop.h"
@@ -519,8 +521,12 @@ int mutt_index_menu (void)
        menu->redraw |= REDRAW_STATUS;
      if (do_buffy_notify)
      {
-       if (mutt_buffy_notify () && option (OPTBEEPNEW))
- 	beep ();
+       if (mutt_buffy_notify ())
+       {
+         menu->redraw |= REDRAW_FULL;
+         if (option (OPTBEEPNEW))
+           beep ();
+       }
      }
      else
        do_buffy_notify = 1;
@@ -532,6 +538,7 @@ int mutt_index_menu (void)
     if (menu->redraw & REDRAW_FULL)
     {
       menu_redraw_full (menu);
+      draw_sidebar(menu->menu);
       mutt_show_error ();
     }
 
@@ -554,10 +561,13 @@ int mutt_index_menu (void)
 
       if (menu->redraw & REDRAW_STATUS)
       {
+        DrawFullLine = 1;
 	menu_status_line (buf, sizeof (buf), menu, NONULL (Status));
+        DrawFullLine = 0;
 	CLEARLINE (option (OPTSTATUSONTOP) ? 0 : LINES-2);
 	SETCOLOR (MT_COLOR_STATUS);
         BKGDSET (MT_COLOR_STATUS);
+        set_buffystats(Context);
 	mutt_paddstr (COLS, buf);
 	SETCOLOR (MT_COLOR_NORMAL);
         BKGDSET (MT_COLOR_NORMAL);
@@ -571,7 +581,7 @@ int mutt_index_menu (void)
 	menu->oldcurrent = -1;
 
       if (option (OPTARROWCURSOR))
-	move (menu->current - menu->top + menu->offset, 2);
+	move (menu->current - menu->top + menu->offset, SidebarWidth + 2);
       else if (option (OPTBRAILLEFRIENDLY))
 	move (menu->current - menu->top + menu->offset, 0);
       else
@@ -1069,6 +1079,7 @@ int mutt_index_menu (void)
 	  menu->redraw = REDRAW_FULL;
 	break;
 
+      case OP_SIDEBAR_OPEN:
       case OP_MAIN_CHANGE_FOLDER:
       case OP_MAIN_NEXT_UNREAD_MAILBOX:
 
@@ -1100,7 +1111,11 @@ int mutt_index_menu (void)
 	{
 	  mutt_buffy (buf, sizeof (buf));
 
-	  if (mutt_enter_fname (cp, buf, sizeof (buf), &menu->redraw, 1) == -1)
+          if ( op == OP_SIDEBAR_OPEN ) {
+              if(!CurBuffy)
+                break;
+            strncpy( buf, CurBuffy->path, sizeof(buf) );  
+	    } else if (mutt_enter_fname (cp, buf, sizeof (buf), &menu->redraw, 1) == -1)
 	  {
 	    if (menu->menu == MENU_PAGER)
 	    {
@@ -1118,6 +1133,7 @@ int mutt_index_menu (void)
 	}
 
 	mutt_expand_path (buf, sizeof (buf));
+        set_curbuffy(buf);
 	if (mx_get_magic (buf) <= 0)
 	{
 	  mutt_error (_("%s is not a mailbox."), buf);
@@ -2208,6 +2224,12 @@ int mutt_index_menu (void)
 	mutt_what_key();
 	break;
 
+      case OP_SIDEBAR_SCROLL_UP:
+      case OP_SIDEBAR_SCROLL_DOWN:
+      case OP_SIDEBAR_NEXT:
+      case OP_SIDEBAR_PREV:
+        scroll_sidebar(op, menu->menu);
+        break;
       default:
 	if (menu->menu == MENU_MAIN)
 	  km_error_key (MENU_MAIN);
diff --git a/flags.c b/flags.c
index f0f3d81..d675000 100644
--- a/flags.c
+++ b/flags.c
@@ -22,8 +22,10 @@
 
 #include "mutt.h"
 #include "mutt_curses.h"
+#include "mutt_menu.h"
 #include "sort.h"
 #include "mx.h"
+#include "sidebar.h"
 
 void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
 {
@@ -263,6 +265,7 @@ void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
    */
   if (h->searched && (changed != h->changed || deleted != ctx->deleted || tagged != ctx->tagged || flagged != ctx->flagged))
     h->searched = 0;
+	draw_sidebar(0);
 }
 
 void mutt_tag_set_flag (int flag, int bf)
diff --git a/functions.h b/functions.h
index e8beacb..7e64952 100644
--- a/functions.h
+++ b/functions.h
@@ -169,6 +169,11 @@ struct binding_t OpMain[] = { /* map: index */
   { "decrypt-save",		OP_DECRYPT_SAVE,		NULL },
 
 
+ { "sidebar-scroll-up",	OP_SIDEBAR_SCROLL_UP, NULL },
+ { "sidebar-scroll-down",	OP_SIDEBAR_SCROLL_DOWN, NULL },
+ { "sidebar-next",		OP_SIDEBAR_NEXT, NULL },
+ { "sidebar-prev",		OP_SIDEBAR_PREV, NULL },
+ { "sidebar-open",		OP_SIDEBAR_OPEN, NULL },
   { NULL,			0,				NULL }
 };
 
@@ -272,6 +277,11 @@ struct binding_t OpPager[] = { /* map: pager */
 
   { "what-key",		OP_WHAT_KEY,		NULL },
 
+  { "sidebar-scroll-up",	OP_SIDEBAR_SCROLL_UP, NULL },
+  { "sidebar-scroll-down",	OP_SIDEBAR_SCROLL_DOWN, NULL },
+  { "sidebar-next",	OP_SIDEBAR_NEXT, NULL },
+  { "sidebar-prev",	OP_SIDEBAR_PREV, NULL },
+  { "sidebar-open", OP_SIDEBAR_OPEN, NULL },
   { NULL,		0,				NULL }
 };
 
diff --git a/globals.h b/globals.h
index 62d831d..ced77ce 100644
--- a/globals.h
+++ b/globals.h
@@ -117,6 +117,7 @@ WHERE short SearchContext;
 WHERE char *SendCharset;
 WHERE char *Sendmail;
 WHERE char *Shell;
+WHERE char *SidebarDelim;
 WHERE char *Signature;
 WHERE char *SimpleSearch;
 #if USE_SMTP
@@ -207,6 +208,9 @@ WHERE short ScoreThresholdDelete;
 WHERE short ScoreThresholdRead;
 WHERE short ScoreThresholdFlag;
 
+WHERE struct buffy_t *CurBuffy INITVAL(0);
+WHERE short DrawFullLine INITVAL(0);
+WHERE short SidebarWidth;
 #ifdef USE_IMAP
 WHERE short ImapKeepalive;
 WHERE short ImapPipelineDepth;
diff --git a/imap/command.c b/imap/command.c
index 3330d98..93ee744 100644
--- a/imap/command.c
+++ b/imap/command.c
@@ -1011,6 +1011,13 @@ static void cmd_parse_status (IMAP_DATA* idata, char* s)
 	     opened */
 	  status->uidnext = oldun;
 
+        /* Added to make the sidebar show the correct numbers */
+        if (status->messages)
+        {
+          inc->msgcount = status->messages;
+          inc->msg_unread = status->unseen;
+        }
+
         FREE (&value);
         return;
       }
diff --git a/imap/imap.c b/imap/imap.c
index f08b4ea..89c9823 100644
--- a/imap/imap.c
+++ b/imap/imap.c
@@ -1521,7 +1521,7 @@ int imap_buffy_check (int force)
 
     imap_munge_mbox_name (munged, sizeof (munged), name);
     snprintf (command, sizeof (command),
-	      "STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT)", munged);
+	      "STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT MESSAGES)", munged);
 
     if (imap_exec (idata, command, IMAP_CMD_QUEUE) < 0)
     {
diff --git a/init.h b/init.h
index ab262f1..c3fe397 100644
--- a/init.h
+++ b/init.h
@@ -1953,6 +1953,22 @@ struct option_t MuttVars[] = {
   ** not used.
   ** (PGP only)
   */
+  {"sidebar_delim", DT_STR, R_BOTH, UL &SidebarDelim, "|"},
+  /*
+  ** .pp
+  ** This specifies the delimiter between the sidebar (if visible) and 
+  ** other screens.
+  */
+  { "sidebar_visible", DT_BOOL, R_BOTH, OPTSIDEBAR, 0 },
+  /*
+  ** .pp
+  ** This specifies whether or not to show sidebar (left-side list of folders).
+  */
+  { "sidebar_width", DT_NUM, R_BOTH, UL &SidebarWidth, 0 },
+  /*
+  ** .pp
+  ** The width of the sidebar.
+  */
   { "pgp_use_gpg_agent", DT_BOOL, R_NONE, OPTUSEGPGAGENT, 0},
   /*
   ** .pp
diff --git a/mailbox.h b/mailbox.h
index 91e5dc7..b652628 100644
--- a/mailbox.h
+++ b/mailbox.h
@@ -27,6 +27,7 @@
 #define M_NEWFOLDER	(1<<4) /* create a new folder - same as M_APPEND, but uses
 				* safe_fopen() for mbox-style folders.
 				*/
+#define M_PEEK		(1<<5) /* revert atime back after taking a look (if applicable) */
 
 /* mx_open_new_message() */
 #define M_ADD_FROM	1	/* add a From_ line */
diff --git a/mbox.c b/mbox.c
index afd1be4..0dc4580 100644
--- a/mbox.c
+++ b/mbox.c
@@ -100,6 +100,7 @@ int mmdf_parse_mailbox (CONTEXT *ctx)
     mutt_perror (ctx->path);
     return (-1);
   }
+  ctx->atime = sb.st_atime;
   ctx->mtime = sb.st_mtime;
   ctx->size = sb.st_size;
 
@@ -251,6 +252,7 @@ int mbox_parse_mailbox (CONTEXT *ctx)
 
   ctx->size = sb.st_size;
   ctx->mtime = sb.st_mtime;
+  ctx->atime = sb.st_atime;
 
 #ifdef NFS_ATTRIBUTE_HACK
   if (sb.st_mtime > sb.st_atime)
diff --git a/menu.c b/menu.c
index ff830f3..6a1f5db 100644
--- a/menu.c
+++ b/menu.c
@@ -24,6 +24,7 @@
 #include "mutt_curses.h"
 #include "mutt_menu.h"
 #include "mbyte.h"
+#include "sidebar.h"
 
 #include <string.h>
 #include <stdlib.h>
@@ -156,7 +157,7 @@ static void menu_pad_string (char *s, size_t n)
 {
   char *scratch = safe_strdup (s);
   int shift = option (OPTARROWCURSOR) ? 3 : 0;
-  int cols = COLS - shift;
+  int cols = COLS - shift - SidebarWidth;
 
   mutt_format_string (s, n, cols, cols, FMT_LEFT, ' ', scratch, mutt_strlen (scratch), 1);
   s[n - 1] = 0;
@@ -207,6 +208,7 @@ void menu_redraw_index (MUTTMENU *menu)
   char buf[LONG_STRING];
   int i;
 
+  draw_sidebar(1);
   for (i = menu->top; i < menu->top + menu->pagelen; i++)
   {
     if (i < menu->max)
@@ -217,7 +219,7 @@ void menu_redraw_index (MUTTMENU *menu)
       if (option (OPTARROWCURSOR))
       {
         attrset (menu->color (i));
-	CLEARLINE (i - menu->top + menu->offset);
+	CLEARLINE_WIN (i - menu->top + menu->offset);
 
 	if (i == menu->current)
 	{
@@ -246,14 +248,14 @@ void menu_redraw_index (MUTTMENU *menu)
 	  BKGDSET (MT_COLOR_INDICATOR);
 	}
 
-	CLEARLINE (i - menu->top + menu->offset);
+	CLEARLINE_WIN (i - menu->top + menu->offset);
 	print_enriched_string (menu->color(i), (unsigned char *) buf, i != menu->current);
         SETCOLOR (MT_COLOR_NORMAL);
         BKGDSET (MT_COLOR_NORMAL);
       }
     }
     else
-      CLEARLINE (i - menu->top + menu->offset);
+      CLEARLINE_WIN (i - menu->top + menu->offset);
   }
   menu->redraw = 0;
 }
@@ -268,7 +270,7 @@ void menu_redraw_motion (MUTTMENU *menu)
     return;
   }
   
-  move (menu->oldcurrent + menu->offset - menu->top, 0);
+  move (menu->oldcurrent + menu->offset - menu->top, SidebarWidth);
   SETCOLOR (MT_COLOR_NORMAL);
   BKGDSET (MT_COLOR_NORMAL);
 
@@ -283,13 +285,13 @@ void menu_redraw_motion (MUTTMENU *menu)
       clrtoeol ();
       menu_make_entry (buf, sizeof (buf), menu, menu->oldcurrent);
       menu_pad_string (buf, sizeof (buf));
-      move (menu->oldcurrent + menu->offset - menu->top, 3);
+      move (menu->oldcurrent + menu->offset - menu->top, SidebarWidth + 3);
       print_enriched_string (menu->color(menu->oldcurrent), (unsigned char *) buf, 1);
       SETCOLOR (MT_COLOR_NORMAL);
     }
 
     /* now draw it in the new location */
-    move (menu->current + menu->offset - menu->top, 0);
+    move (menu->current + menu->offset - menu->top, SidebarWidth);
     attrset (menu->color (menu->current));
     ADDCOLOR (MT_COLOR_INDICATOR);
     addstr ("->");
@@ -310,7 +312,7 @@ void menu_redraw_motion (MUTTMENU *menu)
     attrset (menu->color (menu->current));
     ADDCOLOR (MT_COLOR_INDICATOR);
     BKGDSET (MT_COLOR_INDICATOR);
-    CLEARLINE (menu->current - menu->top + menu->offset);
+    CLEARLINE_WIN (menu->current - menu->top + menu->offset);
     print_enriched_string (menu->color(menu->current), (unsigned char *) buf, 0);
     SETCOLOR (MT_COLOR_NORMAL);
     BKGDSET (MT_COLOR_NORMAL);
@@ -322,7 +324,7 @@ void menu_redraw_current (MUTTMENU *menu)
 {
   char buf[LONG_STRING];
   
-  move (menu->current + menu->offset - menu->top, 0);
+  move (menu->current + menu->offset - menu->top, SidebarWidth);
   menu_make_entry (buf, sizeof (buf), menu, menu->current);
   menu_pad_string (buf, sizeof (buf));
 
@@ -875,7 +877,7 @@ int mutt_menuLoop (MUTTMENU *menu)
     
     
     if (option (OPTARROWCURSOR))
-      move (menu->current - menu->top + menu->offset, 2);
+      move (menu->current - menu->top + menu->offset, SidebarWidth + 2);
     else if (option (OPTBRAILLEFRIENDLY))
       move (menu->current - menu->top + menu->offset, 0);
     else
diff --git a/mh.c b/mh.c
index 21f516b..6e52eb4 100644
--- a/mh.c
+++ b/mh.c
@@ -235,13 +235,37 @@ int mh_buffy (const char *path)
 
   if (mh_read_sequences (&mhs, path) < 0)
     return 0;
+
   for (i = 0; !r && i <= mhs.max; i++)
-    if (mhs_check (&mhs, i) & MH_SEQ_UNSEEN)
+    if (mhs_check (&mhs, i) & MH_SEQ_UNSEEN) {
       r = 1;
+    }
   mhs_free_sequences (&mhs);
   return r;
 }
 
+void mh_buffy_update (const char *path, int *msgcount, int *msg_unread, int *msg_flagged)
+{
+  int i;
+  struct mh_sequences mhs;
+  memset (&mhs, 0, sizeof (mhs));
+
+  if (mh_read_sequences (&mhs, path) < 0)
+    return;
+
+  msgcount = 0;
+  msg_unread = 0;
+  msg_flagged = 0;
+  for (i = 0; i <= mhs.max; i++)
+    msgcount++;
+    if (mhs_check (&mhs, i) & MH_SEQ_UNSEEN) {
+      msg_unread++;
+    }
+    if (mhs_check (&mhs, i) & MH_SEQ_FLAGGED)
+      msg_flagged++;
+  mhs_free_sequences (&mhs);
+}
+
 static int mh_mkstemp (CONTEXT * dest, FILE ** fp, char **tgt)
 {
   int fd;
diff --git a/mutt.h b/mutt.h
index 578d111..25822e5 100644
--- a/mutt.h
+++ b/mutt.h
@@ -419,6 +419,7 @@ enum
   OPTSAVEEMPTY,
   OPTSAVENAME,
   OPTSCORE,
+  OPTSIDEBAR,
   OPTSIGDASHES,
   OPTSIGONTOP,
   OPTSORTRE,
@@ -859,6 +860,7 @@ typedef struct _context
 {
   char *path;
   FILE *fp;
+  time_t atime;
   time_t mtime;
   off_t size;
   off_t vsize;
@@ -893,6 +895,7 @@ typedef struct _context
   unsigned int quiet : 1;	/* inhibit status messages? */
   unsigned int collapsed : 1;   /* are all threads collapsed? */
   unsigned int closing : 1;	/* mailbox is being closed */
+  unsigned int peekonly : 1;	/* just taking a glance, revert atime */
 
   /* driver hooks */
   void *data;			/* driver specific data */
diff --git a/mutt_curses.h b/mutt_curses.h
index 854e3d5..5f61048 100644
--- a/mutt_curses.h
+++ b/mutt_curses.h
@@ -64,6 +64,7 @@
 #undef lines
 #endif /* lines */
 
+#define CLEARLINE_WIN(x) move(x,SidebarWidth), clrtoeol()
 #define CLEARLINE(x) move(x,0), clrtoeol()
 #define CENTERLINE(x,y) move(y, (COLS-strlen(x))/2), addstr(x)
 #define BEEP() do { if (option (OPTBEEP)) beep(); } while (0)
@@ -126,6 +127,8 @@ enum
   MT_COLOR_BOLD,
   MT_COLOR_UNDERLINE,
   MT_COLOR_INDEX,
+  MT_COLOR_NEW,
+  MT_COLOR_FLAGGED,
   MT_COLOR_MAX
 };
 
diff --git a/muttlib.c b/muttlib.c
index 2160ceb..0581610 100644
--- a/muttlib.c
+++ b/muttlib.c
@@ -1286,6 +1286,8 @@ void mutt_FormatString (char *dest,		/* output buffer */
 	  pl = pw = 1;
 
 	/* see if there's room to add content, else ignore */
+        if ( DrawFullLine )
+        {
 	if ((col < COLS && wlen < destlen) || soft)
 	{
 	  int pad;
@@ -1329,6 +1331,52 @@ void mutt_FormatString (char *dest,		/* output buffer */
 	  col += wid;
 	  src += pl;
 	}
+        }
+        else
+        {
+	if ((col < COLS-SidebarWidth && wlen < destlen) || soft)
+        {
+	  int pad;
+
+	  /* get contents after padding */
+	  mutt_FormatString (buf, sizeof (buf), 0, src + pl, callback, data, flags);
+	  len = mutt_strlen (buf);
+	  wid = mutt_strwidth (buf);
+
+	  /* try to consume as many columns as we can, if we don't have
+	   * memory for that, use as much memory as possible */
+	  pad = (COLS - SidebarWidth - col - wid) / pw;
+	  if (pad > 0 && wlen + (pad * pl) + len > destlen)
+	    pad = ((signed)(destlen - wlen - len)) / pl;
+	  if (pad > 0)
+	  {
+	    while (pad--)
+	    {
+	      memcpy (wptr, src, pl);
+	      wptr += pl;
+	      wlen += pl;
+	      col += pw;
+	    }
+	  }
+	  else if (soft && pad < 0)
+	  {
+	    /* \0-terminate dest for length computation in mutt_wstr_trunc() */
+	    *wptr = 0;
+	    /* make sure right part is at most as wide as display */
+	    len = mutt_wstr_trunc (buf, destlen, COLS, &wid);
+	    /* truncate left so that right part fits completely in */
+	    wlen = mutt_wstr_trunc (dest, destlen - len, col + pad, &col);
+	    wptr = dest + wlen;
+	  }
+	  if (len + wlen > destlen)
+	    len = mutt_wstr_trunc (buf, destlen - wlen, COLS - SidebarWidth - col, NULL);
+	  memcpy (wptr, buf, len);
+	  wptr += len;
+	  wlen += len;
+	  col += wid;
+	  src += pl;
+	}
+        }
 	break; /* skip rest of input */
       }
       else if (ch == '|')
diff --git a/mx.c b/mx.c
index 7e52714..4dc286a 100644
--- a/mx.c
+++ b/mx.c
@@ -580,6 +580,7 @@ static int mx_open_mailbox_append (CONTEXT *ctx, int flags)
  *		M_APPEND	open mailbox for appending
  *		M_READONLY	open mailbox in read-only mode
  *		M_QUIET		only print error messages
+ *		M_PEEK		revert atime where applicable
  *	ctx	if non-null, context struct to use
  */
 CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
@@ -602,6 +603,8 @@ CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
     ctx->quiet = 1;
   if (flags & M_READONLY)
     ctx->readonly = 1;
+  if (flags & M_PEEK)
+    ctx->peekonly = 1;
 
   if (flags & (M_APPEND|M_NEWFOLDER))
   {
@@ -701,9 +704,21 @@ CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
 void mx_fastclose_mailbox (CONTEXT *ctx)
 {
   int i;
+#ifndef BUFFY_SIZE
+  struct utimbuf ut;
+#endif
 
   if(!ctx) 
     return;
+#ifndef BUFFY_SIZE
+  /* fix up the times so buffy won't get confused */
+  if (ctx->peekonly && ctx->path && ctx->mtime > ctx->atime)
+  {
+    ut.actime = ctx->atime;
+    ut.modtime = ctx->mtime;
+    utime (ctx->path, &ut); 
+  }
+#endif
 
   /* never announce that a mailbox we've just left has new mail. #3290
    * XXX: really belongs in mx_close_mailbox, but this is a nice hook point */
diff --git a/mx.h b/mx.h
index 136ae5f..d037aa0 100644
--- a/mx.h
+++ b/mx.h
@@ -58,6 +58,7 @@ int mh_read_dir (CONTEXT *, const char *);
 int mh_sync_mailbox (CONTEXT *, int *);
 int mh_check_mailbox (CONTEXT *, int *);
 int mh_buffy (const char *);
+void mh_buffy_update (const char *, int *, int *, int *);
 int mh_check_empty (const char *);
 
 int maildir_read_dir (CONTEXT *);
diff --git a/pager.c b/pager.c
index e19174c..b38fb66 100644
--- a/pager.c
+++ b/pager.c
@@ -29,6 +29,7 @@
 #include "pager.h"
 #include "attach.h"
 #include "mbyte.h"
+#include "sidebar.h"
 
 #include "mutt_crypt.h"
 
@@ -1095,6 +1096,7 @@ static int format_line (struct line_t **lineInfo, int n, unsigned char *buf,
   wchar_t wc;
   mbstate_t mbstate;
   int wrap_cols = mutt_term_width ((flags & M_PAGER_NOWRAP) ? 0 : Wrap);
+  wrap_cols -= SidebarWidth;
 
   if (check_attachment_marker ((char *)buf) == 0)
     wrap_cols = COLS;
@@ -1745,7 +1747,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
     if ((redraw & REDRAW_BODY) || topline != oldtopline)
     {
       do {
-	move (bodyoffset, 0);
+	move (bodyoffset, SidebarWidth);
 	curline = oldtopline = topline;
 	lines = 0;
 	force_redraw = 0;
@@ -1758,6 +1760,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
 			    &QuoteList, &q_level, &force_redraw, &SearchRE) > 0)
 	    lines++;
 	  curline++;
+  	  move(lines + bodyoffset, SidebarWidth);
 	}
 	last_offset = lineInfo[curline].offset;
       } while (force_redraw);
@@ -1771,6 +1774,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
 	  addch ('~');
 	addch ('\n');
 	lines++;
+  	move(lines + bodyoffset, SidebarWidth);
       }
       /* We are going to update the pager status bar, so it isn't
        * necessary to reset to normal color now. */
@@ -1794,21 +1798,21 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
       /* print out the pager status bar */
       SETCOLOR (MT_COLOR_STATUS);
       BKGDSET (MT_COLOR_STATUS);
-      CLEARLINE (statusoffset);
+      CLEARLINE_WIN (statusoffset);
 
       if (IsHeader (extra) || IsMsgAttach (extra))
       {
-	size_t l1 = COLS * MB_LEN_MAX;
+	size_t l1 = (COLS-SidebarWidth) * MB_LEN_MAX;
 	size_t l2 = sizeof (buffer);
 	hfi.hdr = (IsHeader (extra)) ? extra->hdr : extra->bdy->hdr;
 	mutt_make_string_info (buffer, l1 < l2 ? l1 : l2, NONULL (PagerFmt), &hfi, M_FORMAT_MAKEPRINT);
-	mutt_paddstr (COLS, buffer);
+	mutt_paddstr (COLS-SidebarWidth, buffer);
       }
       else
       {
 	char bn[STRING];
 	snprintf (bn, sizeof (bn), "%s (%s)", banner, pager_progress_str);
-	mutt_paddstr (COLS, bn);
+	mutt_paddstr (COLS-SidebarWidth, bn);
       }
       BKGDSET (MT_COLOR_NORMAL);
       SETCOLOR (MT_COLOR_NORMAL);
@@ -1819,18 +1823,23 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
       /* redraw the pager_index indicator, because the
        * flags for this message might have changed. */
       menu_redraw_current (index);
+      draw_sidebar(MENU_PAGER);
 
       /* print out the index status bar */
       menu_status_line (buffer, sizeof (buffer), index, NONULL(Status));
  
-      move (indexoffset + (option (OPTSTATUSONTOP) ? 0 : (indexlen - 1)), 0);
+      move (indexoffset + (option (OPTSTATUSONTOP) ? 0 : (indexlen - 1)), SidebarWidth);
       SETCOLOR (MT_COLOR_STATUS);
       BKGDSET (MT_COLOR_STATUS);
-      mutt_paddstr (COLS, buffer);
+      mutt_paddstr (COLS-SidebarWidth, buffer);
       SETCOLOR (MT_COLOR_NORMAL);
       BKGDSET (MT_COLOR_NORMAL);
     }
 
+    /* if we're not using the index, update every time */
+    if ( index == 0 )
+      draw_sidebar(MENU_PAGER);
+
     redraw = 0;
 
     if (option(OPTBRAILLEFRIENDLY)) {
@@ -2756,6 +2765,13 @@ search_next:
 	mutt_what_key ();
 	break;
 
+      case OP_SIDEBAR_SCROLL_UP:
+      case OP_SIDEBAR_SCROLL_DOWN:
+      case OP_SIDEBAR_NEXT:
+      case OP_SIDEBAR_PREV:
+	scroll_sidebar(ch, MENU_PAGER);
+ 	break;
+
       default:
 	ch = -1;
 	break;
diff --git a/sidebar.c b/sidebar.c
new file mode 100644
index 0000000..f9413be
--- /dev/null
+++ b/sidebar.c
@@ -0,0 +1,336 @@
+/*
+ * Copyright (C) ????-2004 Justin Hibbits <jrh29@po.cwru.edu>
+ * Copyright (C) 2004 Thomer M. Gil <mutt@thomer.com>
+ * 
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ * 
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ * 
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
+ */ 
+
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+#include "mutt_menu.h"
+#include "mutt_curses.h"
+#include "sidebar.h"
+#include "buffy.h"
+#include <libgen.h>
+#include "keymap.h"
+#include <stdbool.h>
+
+/*BUFFY *CurBuffy = 0;*/
+static BUFFY *TopBuffy = 0;
+static BUFFY *BottomBuffy = 0;
+static int known_lines = 0;
+
+static int quick_log10(int n)
+{
+        char string[32];
+        sprintf(string, "%d", n);
+        return strlen(string);
+}
+
+void calc_boundaries (int menu)
+{
+	BUFFY *tmp = Incoming;
+
+	if ( known_lines != LINES ) {
+		TopBuffy = BottomBuffy = 0;
+		known_lines = LINES;
+	}
+	for ( ; tmp->next != 0; tmp = tmp->next )
+		tmp->next->prev = tmp;
+
+	if ( TopBuffy == 0 && BottomBuffy == 0 )
+		TopBuffy = Incoming;
+	if ( BottomBuffy == 0 ) {
+		int count = LINES - 2 - (menu != MENU_PAGER || option(OPTSTATUSONTOP));
+		BottomBuffy = TopBuffy;
+		while ( --count && BottomBuffy->next )
+			BottomBuffy = BottomBuffy->next;
+	}
+	else if ( TopBuffy == CurBuffy->next ) {
+		int count = LINES - 2 - (menu != MENU_PAGER);
+		BottomBuffy = CurBuffy;
+		tmp = BottomBuffy;
+		while ( --count && tmp->prev)
+			tmp = tmp->prev;
+		TopBuffy = tmp;
+	}
+	else if ( BottomBuffy == CurBuffy->prev ) {
+		int count = LINES - 2 - (menu != MENU_PAGER);
+		TopBuffy = CurBuffy;
+		tmp = TopBuffy;
+		while ( --count && tmp->next )
+			tmp = tmp->next;
+		BottomBuffy = tmp;
+	}
+}
+
+char *make_sidebar_entry(char *box, int size, int new, int flagged)
+{
+	static char *entry = 0;
+	char *c;
+	int i = 0;
+	int delim_len = strlen(SidebarDelim);
+
+	c = realloc(entry, SidebarWidth - delim_len + 2);
+	if ( c ) entry = c;
+	entry[SidebarWidth - delim_len + 1] = 0;
+	for (; i < SidebarWidth - delim_len + 1; entry[i++] = ' ' );
+	i = strlen(box);
+	strncpy( entry, box, i < (SidebarWidth - delim_len + 1) ? i : (SidebarWidth - delim_len + 1) );
+
+        if (size == -1)
+                sprintf(entry + SidebarWidth - delim_len - 3, "?");
+        else if ( new ) {
+          if (flagged > 0) {
+              sprintf(
+		        entry + SidebarWidth - delim_len - 5 - quick_log10(size) - quick_log10(new) - quick_log10(flagged),
+		        "% d(%d)[%d]", size, new, flagged);
+          } else {
+              sprintf(
+                      entry + SidebarWidth - delim_len - 3 - quick_log10(size) - quick_log10(new),
+                      "% d(%d)", size, new);
+          }
+        } else if (flagged > 0) {
+              sprintf( entry + SidebarWidth - delim_len - 3 - quick_log10(size) - quick_log10(flagged), "% d[%d]", size, flagged);
+        } else {
+              sprintf( entry + SidebarWidth - delim_len - 1 - quick_log10(size), "% d", size);
+        }
+	return entry;
+}
+
+void set_curbuffy(char buf[LONG_STRING])
+{
+  BUFFY* tmp = CurBuffy = Incoming;
+
+  if (!Incoming)
+    return;
+
+  while(1) {
+    if(!strcmp(tmp->path, buf)) {
+      CurBuffy = tmp;
+      break;
+    }
+
+    if(tmp->next)
+      tmp = tmp->next;
+    else
+      break;
+  }
+}
+
+int draw_sidebar(int menu) {
+
+	int lines = option(OPTHELP) ? 1 : 0;
+    lines += option(OPTSTATUSONTOP) ? 1 : 0;
+
+	BUFFY *tmp;
+#ifndef USE_SLANG_CURSES
+        attr_t attrs;
+#endif
+        short delim_len = strlen(SidebarDelim);
+        short color_pair;
+
+        static bool initialized = false;
+        static int prev_show_value;
+        static short saveSidebarWidth;
+
+        /* initialize first time */
+        if(!initialized) {
+                prev_show_value = option(OPTSIDEBAR);
+                saveSidebarWidth = SidebarWidth;
+                if(!option(OPTSIDEBAR)) SidebarWidth = 0;
+                initialized = true;
+        }
+
+        /* save or restore the value SidebarWidth */
+        if(prev_show_value != option(OPTSIDEBAR)) {
+                if(prev_show_value && !option(OPTSIDEBAR)) {
+                        saveSidebarWidth = SidebarWidth;
+                        SidebarWidth = 0;
+                } else if(!prev_show_value && option(OPTSIDEBAR)) {
+                        SidebarWidth = saveSidebarWidth;
+                }
+                prev_show_value = option(OPTSIDEBAR);
+        }
+
+
+//	if ( SidebarWidth == 0 ) return 0;
+       if (SidebarWidth > 0 && option (OPTSIDEBAR)
+           && delim_len >= SidebarWidth) {
+         unset_option (OPTSIDEBAR);
+         /* saveSidebarWidth = SidebarWidth; */
+         if (saveSidebarWidth > delim_len) {
+           SidebarWidth = saveSidebarWidth;
+           mutt_error (_("Value for sidebar_delim is too long. Disabling sidebar."));
+           sleep (2);
+         } else {
+           SidebarWidth = 0;
+           mutt_error (_("Value for sidebar_delim is too long. Disabling sidebar. Please set your sidebar_width to a sane value."));
+           sleep (4); /* the advise to set a sane value should be seen long enough */
+         }
+         saveSidebarWidth = 0;
+         return (0);
+       }
+
+    if ( SidebarWidth == 0 || !option(OPTSIDEBAR)) {
+      if (SidebarWidth > 0) {
+        saveSidebarWidth = SidebarWidth;
+        SidebarWidth = 0;
+      }
+      unset_option(OPTSIDEBAR);
+      return 0;
+    }
+
+        /* get attributes for divider */
+	SETCOLOR(MT_COLOR_STATUS);
+#ifndef USE_SLANG_CURSES
+        attr_get(&attrs, &color_pair, 0);
+#else
+        color_pair = attr_get();
+#endif
+	SETCOLOR(MT_COLOR_NORMAL);
+
+	/* draw the divider */
+
+	for ( ; lines < LINES-1-(menu != MENU_PAGER || option(OPTSTATUSONTOP)); lines++ ) {
+		move(lines, SidebarWidth - delim_len);
+		addstr(NONULL(SidebarDelim));
+#ifndef USE_SLANG_CURSES
+                mvchgat(lines, SidebarWidth - delim_len, delim_len, 0, color_pair, NULL);
+#endif
+	}
+
+	if ( Incoming == 0 ) return 0;
+	lines = option(OPTHELP) ? 1 : 0; /* go back to the top */
+    lines += option(OPTSTATUSONTOP) ? 1 : 0;
+
+	if ( known_lines != LINES || TopBuffy == 0 || BottomBuffy == 0 ) 
+		calc_boundaries(menu);
+	if ( CurBuffy == 0 ) CurBuffy = Incoming;
+
+	tmp = TopBuffy;
+
+	SETCOLOR(MT_COLOR_NORMAL);
+
+	for ( ; tmp && lines < LINES-1 - (menu != MENU_PAGER || option(OPTSTATUSONTOP)); tmp = tmp->next ) {
+		if ( tmp == CurBuffy )
+			SETCOLOR(MT_COLOR_INDICATOR);
+		else if ( tmp->msg_unread > 0 )
+			SETCOLOR(MT_COLOR_NEW);
+		else if ( tmp->msg_flagged > 0 )
+		        SETCOLOR(MT_COLOR_FLAGGED);
+		else
+			SETCOLOR(MT_COLOR_NORMAL);
+
+		move( lines, 0 );
+		if ( Context && !strcmp( tmp->path, Context->path ) ) {
+			tmp->msg_unread = Context->unread;
+			tmp->msgcount = Context->msgcount;
+			tmp->msg_flagged = Context->flagged;
+		}
+		// check whether Maildir is a prefix of the current folder's path
+		short maildir_is_prefix = 0;
+		if ( (strlen(tmp->path) > strlen(Maildir)) &&
+			(strncmp(Maildir, tmp->path, strlen(Maildir)) == 0) )
+        		maildir_is_prefix = 1;
+		// calculate depth of current folder and generate its display name with indented spaces
+		int sidebar_folder_depth = 0;
+		char *sidebar_folder_name;
+		sidebar_folder_name = basename(tmp->path);
+		if ( maildir_is_prefix ) {
+			char *tmp_folder_name;
+			int i;
+			tmp_folder_name = tmp->path + strlen(Maildir);
+			for (i = 0; i < strlen(tmp->path) - strlen(Maildir); i++) {
+				if (tmp_folder_name[i] == '/') sidebar_folder_depth++;
+			}   
+			if (sidebar_folder_depth > 0) {
+				sidebar_folder_name = malloc(strlen(basename(tmp->path)) + sidebar_folder_depth + 1);
+				for (i=0; i < sidebar_folder_depth; i++)
+					sidebar_folder_name[i]=' ';
+				sidebar_folder_name[i]=0;
+				strncat(sidebar_folder_name, basename(tmp->path), strlen(basename(tmp->path)) + sidebar_folder_depth);
+			}
+		}
+		printw( "%.*s", SidebarWidth - delim_len + 1,
+			make_sidebar_entry(sidebar_folder_name, tmp->msgcount,
+			tmp->msg_unread, tmp->msg_flagged));
+		if (sidebar_folder_depth > 0)
+		        free(sidebar_folder_name);
+		lines++;
+	}
+	SETCOLOR(MT_COLOR_NORMAL);
+	for ( ; lines < LINES-1 - (menu != MENU_PAGER || option(OPTSTATUSONTOP)); lines++ ) {
+		int i = 0;
+		move( lines, 0 );
+		for ( ; i < SidebarWidth - delim_len; i++ )
+			addch(' ');
+	}
+	return 0;
+}
+
+
+void set_buffystats(CONTEXT* Context)
+{
+        BUFFY *tmp = Incoming;
+        while(tmp) {
+                if(Context && !strcmp(tmp->path, Context->path)) {
+			tmp->msg_unread = Context->unread;
+			tmp->msgcount = Context->msgcount;
+                        break;
+                }
+                tmp = tmp->next;
+        }
+}
+
+void scroll_sidebar(int op, int menu)
+{
+        if(!SidebarWidth) return;
+        if(!CurBuffy) return;
+
+	switch (op) {
+		case OP_SIDEBAR_NEXT:
+			if ( CurBuffy->next == NULL ) return;
+			CurBuffy = CurBuffy->next;
+			break;
+		case OP_SIDEBAR_PREV:
+			if ( CurBuffy->prev == NULL ) return;
+			CurBuffy = CurBuffy->prev;
+			break;
+		case OP_SIDEBAR_SCROLL_UP:
+			CurBuffy = TopBuffy;
+			if ( CurBuffy != Incoming ) {
+				calc_boundaries(menu);
+				CurBuffy = CurBuffy->prev;
+			}
+			break;
+		case OP_SIDEBAR_SCROLL_DOWN:
+			CurBuffy = BottomBuffy;
+			if ( CurBuffy->next ) {
+				calc_boundaries(menu);
+				CurBuffy = CurBuffy->next;
+			}
+			break;
+		default:
+			return;
+	}
+	calc_boundaries(menu);
+	draw_sidebar(menu);
+}
+
diff --git a/sidebar.h b/sidebar.h
new file mode 100644
index 0000000..d195f11
--- /dev/null
+++ b/sidebar.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) ????-2004 Justin Hibbits <jrh29@po.cwru.edu>
+ * Copyright (C) 2004 Thomer M. Gil <mutt@thomer.com>
+ * 
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ * 
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ * 
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
+ */ 
+
+#ifndef SIDEBAR_H
+#define SIDEBAR_H
+
+struct MBOX_LIST {
+	char *path;
+	int msgcount;
+	int new;
+} MBLIST;
+
+/* parameter is whether or not to go to the status line */
+/* used for omitting the last | that covers up the status bar in the index */
+int draw_sidebar(int);
+void scroll_sidebar(int, int);
+void set_curbuffy(char*);
+void set_buffystats(CONTEXT*);
+
+#endif /* SIDEBAR_H */
-- 
1.7.7.3

From efb7c86ce7488222e4ea1a1111aa310351dce7d6 Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Mon, 24 Oct 2011 16:32:39 +0200
Subject: [PATCH 03/19] applying debian/patches/mutt-patched/sidebar-dotted

Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 init.h    |    5 +++++
 mutt.h    |    1 +
 sidebar.c |   15 ++++++++++++---
 3 files changed, 18 insertions(+), 3 deletions(-)

diff --git a/init.h b/init.h
index c3fe397..4671984 100644
--- a/init.h
+++ b/init.h
@@ -1969,6 +1969,11 @@ struct option_t MuttVars[] = {
   ** .pp
   ** The width of the sidebar.
   */
+  { "sidebar_shortpath", DT_BOOL, R_BOTH, OPTSIDEBARSHORTPATH, 0 },
+  /*
+  ** .pp
+  ** Should the sidebar shorten the path showed.
+  */
   { "pgp_use_gpg_agent", DT_BOOL, R_NONE, OPTUSEGPGAGENT, 0},
   /*
   ** .pp
diff --git a/mutt.h b/mutt.h
index 25822e5..b9bf895 100644
--- a/mutt.h
+++ b/mutt.h
@@ -420,6 +420,7 @@ enum
   OPTSAVENAME,
   OPTSCORE,
   OPTSIDEBAR,
+  OPTSIDEBARSHORTPATH,
   OPTSIGDASHES,
   OPTSIGONTOP,
   OPTSORTRE,
diff --git a/sidebar.c b/sidebar.c
index f9413be..94127bb 100644
--- a/sidebar.c
+++ b/sidebar.c
@@ -258,14 +258,23 @@ int draw_sidebar(int menu) {
 			int i;
 			tmp_folder_name = tmp->path + strlen(Maildir);
 			for (i = 0; i < strlen(tmp->path) - strlen(Maildir); i++) {
-				if (tmp_folder_name[i] == '/') sidebar_folder_depth++;
+ 				if (tmp_folder_name[i] == '/'  || tmp_folder_name[i] == '.') sidebar_folder_depth++;
 			}   
 			if (sidebar_folder_depth > 0) {
-				sidebar_folder_name = malloc(strlen(basename(tmp->path)) + sidebar_folder_depth + 1);
+ 				if (option(OPTSIDEBARSHORTPATH)) {
+ 					tmp_folder_name = strrchr(tmp->path, '.');
+ 					if (tmp_folder_name == NULL)
+ 						tmp_folder_name = tmp->path;
+ 					else
+						tmp_folder_name++;
+ 				}
+ 				else
+ 					tmp_folder_name = tmp->path;
+ 				sidebar_folder_name = malloc(strlen(basename(tmp_folder_name)) + sidebar_folder_depth + 1);
 				for (i=0; i < sidebar_folder_depth; i++)
 					sidebar_folder_name[i]=' ';
 				sidebar_folder_name[i]=0;
-				strncat(sidebar_folder_name, basename(tmp->path), strlen(basename(tmp->path)) + sidebar_folder_depth);
+ 				strncat(sidebar_folder_name, basename(tmp_folder_name), strlen(basename(tmp_folder_name)) + sidebar_folder_depth);
 			}
 		}
 		printw( "%.*s", SidebarWidth - delim_len + 1,
-- 
1.7.7.3

From e15d72e6302b14f7757d0b9670de73944a5d6e05 Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Mon, 24 Oct 2011 16:32:40 +0200
Subject: [PATCH 04/19] applying debian/patches/mutt-patched/sidebar-sorted

Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 init.h    |    5 +++++
 mutt.h    |    1 +
 sidebar.c |   29 +++++++++++++++++++++++++++++
 3 files changed, 35 insertions(+), 0 deletions(-)

diff --git a/init.h b/init.h
index 4671984..4d58f7f 100644
--- a/init.h
+++ b/init.h
@@ -1974,6 +1974,11 @@ struct option_t MuttVars[] = {
   ** .pp
   ** Should the sidebar shorten the path showed.
   */
+  { "sidebar_sort", DT_BOOL, R_BOTH, OPTSIDEBARSORT, 0 },
+  /*
+  ** .pp
+  ** Should the sidebar be sorted.
+  */
   { "pgp_use_gpg_agent", DT_BOOL, R_NONE, OPTUSEGPGAGENT, 0},
   /*
   ** .pp
diff --git a/mutt.h b/mutt.h
index b9bf895..0ed1b8e 100644
--- a/mutt.h
+++ b/mutt.h
@@ -421,6 +421,7 @@ enum
   OPTSCORE,
   OPTSIDEBAR,
   OPTSIDEBARSHORTPATH,
+  OPTSIDEBARSORT,
   OPTSIGDASHES,
   OPTSIGONTOP,
   OPTSORTRE,
diff --git a/sidebar.c b/sidebar.c
index 94127bb..893f69e 100644
--- a/sidebar.c
+++ b/sidebar.c
@@ -54,6 +54,35 @@ void calc_boundaries (int menu)
 	for ( ; tmp->next != 0; tmp = tmp->next )
 		tmp->next->prev = tmp;
 
+	if (option(OPTSIDEBARSORT)) {
+		int needsort=1;
+		BUFFY *prev;
+		BUFFY *next;
+		BUFFY *tmp2;
+		while (needsort==1) {
+			needsort=0;
+			tmp = Incoming;
+			for ( ; tmp ; tmp=tmp->next ) {
+				if (tmp->next != NULL && strcoll(tmp->path, tmp->next->path) > 0) {
+					needsort=1;
+					prev = tmp->prev;
+					next = tmp->next;
+					if (prev != NULL)
+						prev->next = next;
+					else
+						Incoming = next;
+					next->prev = prev;
+					tmp2 = next->next;
+					next->next = tmp;
+					tmp->prev = next;
+					tmp->next = tmp2;
+					if (tmp2 != NULL)
+						tmp2->prev = tmp;
+				}
+			}
+		}
+	}
+
 	if ( TopBuffy == 0 && BottomBuffy == 0 )
 		TopBuffy = Incoming;
 	if ( BottomBuffy == 0 ) {
-- 
1.7.7.3

From c355d27c1ec39e4be10fd35851e7a73659e95803 Mon Sep 17 00:00:00 2001
From: Heiko Schlichting <heiko@Waran.CIS.FU-Berlin.DE>
Date: Sat, 5 Feb 2011 18:31:40 +0100
Subject: [PATCH 05/19] Fix sidebar compilation errors on IRIX systems

This fixes two small issues that make the sidebar patch fail to compile
on IRIX systems. Also, it changes C++-style comment signs to regular C
style ones.

Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 init.h    |    2 +-
 sidebar.c |   12 ++++++------
 2 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/init.h b/init.h
index 4d58f7f..4c81e41 100644
--- a/init.h
+++ b/init.h
@@ -1953,7 +1953,7 @@ struct option_t MuttVars[] = {
   ** not used.
   ** (PGP only)
   */
-  {"sidebar_delim", DT_STR, R_BOTH, UL &SidebarDelim, "|"},
+  {"sidebar_delim", DT_STR, R_BOTH, UL &SidebarDelim, UL "|"},
   /*
   ** .pp
   ** This specifies the delimiter between the sidebar (if visible) and 
diff --git a/sidebar.c b/sidebar.c
index 893f69e..1e903ef 100644
--- a/sidebar.c
+++ b/sidebar.c
@@ -199,7 +199,7 @@ int draw_sidebar(int menu) {
         }
 
 
-//	if ( SidebarWidth == 0 ) return 0;
+       /* if ( SidebarWidth == 0 ) return 0; */
        if (SidebarWidth > 0 && option (OPTSIDEBAR)
            && delim_len >= SidebarWidth) {
          unset_option (OPTSIDEBAR);
@@ -273,15 +273,15 @@ int draw_sidebar(int menu) {
 			tmp->msgcount = Context->msgcount;
 			tmp->msg_flagged = Context->flagged;
 		}
-		// check whether Maildir is a prefix of the current folder's path
+		/* check whether Maildir is a prefix of the current folder's path */
 		short maildir_is_prefix = 0;
 		if ( (strlen(tmp->path) > strlen(Maildir)) &&
 			(strncmp(Maildir, tmp->path, strlen(Maildir)) == 0) )
         		maildir_is_prefix = 1;
-		// calculate depth of current folder and generate its display name with indented spaces
+		/* calculate depth of current folder and generate its display name with indented spaces */
 		int sidebar_folder_depth = 0;
 		char *sidebar_folder_name;
-		sidebar_folder_name = basename(tmp->path);
+		sidebar_folder_name = mutt_basename(tmp->path);
 		if ( maildir_is_prefix ) {
 			char *tmp_folder_name;
 			int i;
@@ -299,11 +299,11 @@ int draw_sidebar(int menu) {
  				}
  				else
  					tmp_folder_name = tmp->path;
- 				sidebar_folder_name = malloc(strlen(basename(tmp_folder_name)) + sidebar_folder_depth + 1);
+				sidebar_folder_name = malloc(strlen(mutt_basename(tmp_folder_name)) + sidebar_folder_depth + 1);
 				for (i=0; i < sidebar_folder_depth; i++)
 					sidebar_folder_name[i]=' ';
 				sidebar_folder_name[i]=0;
- 				strncat(sidebar_folder_name, basename(tmp_folder_name), strlen(basename(tmp_folder_name)) + sidebar_folder_depth);
+				strncat(sidebar_folder_name, mutt_basename(tmp_folder_name), strlen(mutt_basename(tmp_folder_name)) + sidebar_folder_depth);
 			}
 		}
 		printw( "%.*s", SidebarWidth - delim_len + 1,
-- 
1.7.7.3

From ff262956c0e343eead58e6ca10df4d92be6bd9fa Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Mon, 24 Oct 2011 16:43:46 +0200
Subject: [PATCH 06/19] Fix counting of flagged mails in mboxes

In contrast to the `mh_buffy_update' function, `buffy_mbox_update' won't
set mailbox->msg_flagged. This clearly is a bug, because once the
mailbox is opened the correct number of flagged messages is copied over
from the (CONTEXT *) ctx.

Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 buffy.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/buffy.c b/buffy.c
index 719e1c0..5f90a45 100644
--- a/buffy.c
+++ b/buffy.c
@@ -443,6 +443,7 @@ void buffy_mbox_update (BUFFY* mailbox)
   {
     mailbox->msgcount = ctx->msgcount;
     mailbox->msg_unread = ctx->unread;
+    mailbox->msg_flagged = ctx->flagged;
     mx_close_mailbox(ctx, 0);
   }
 }
-- 
1.7.7.3

From 3cfc62d46e20bbe5b41785b295901905a8ac3f1b Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Wed, 26 Oct 2011 17:20:30 +0200
Subject: [PATCH 07/19] Fix various sidebar drawing issues

You can see fairly obvious quirks by setting

    set pager_index_lines=7

and then experimenting with setting and unsetting `status_on_top` and
`help`.

Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 pager.c   |   23 +++++++++++++++++------
 sidebar.c |   27 +++++++++++++++++----------
 2 files changed, 34 insertions(+), 16 deletions(-)

diff --git a/pager.c b/pager.c
index b38fb66..114b97e 100644
--- a/pager.c
+++ b/pager.c
@@ -1573,6 +1573,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
 
   int bodyoffset = 1;			/* offset of first line of real text */
   int statusoffset = 0; 		/* offset for the status bar */
+  int statuswidth;
   int helpoffset = LINES - 2;		/* offset for the help bar. */
   int bodylen = LINES - 2 - bodyoffset; /* length of displayable area */
 
@@ -1790,6 +1791,8 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
       hfi.ctx = Context;
       hfi.pager_progress = pager_progress_str;
 
+      statuswidth = COLS - (option(OPTSTATUSONTOP) && PagerIndexLines > 0 ? SidebarWidth : 0);
+
       if (last_pos < sb.st_size - 1)
 	snprintf(pager_progress_str, sizeof(pager_progress_str), OFF_T_FMT "%%", (100 * last_offset / sb.st_size));
       else
@@ -1798,22 +1801,29 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
       /* print out the pager status bar */
       SETCOLOR (MT_COLOR_STATUS);
       BKGDSET (MT_COLOR_STATUS);
-      CLEARLINE_WIN (statusoffset);
+      if(option(OPTSTATUSONTOP) && PagerIndexLines > 0) {
+          CLEARLINE_WIN (statusoffset);
+      } else {
+          CLEARLINE (statusoffset);
+          DrawFullLine = 1; /* for mutt_make_string_info */
+      }
 
       if (IsHeader (extra) || IsMsgAttach (extra))
       {
-	size_t l1 = (COLS-SidebarWidth) * MB_LEN_MAX;
+	size_t l1 = statuswidth * MB_LEN_MAX;
 	size_t l2 = sizeof (buffer);
 	hfi.hdr = (IsHeader (extra)) ? extra->hdr : extra->bdy->hdr;
 	mutt_make_string_info (buffer, l1 < l2 ? l1 : l2, NONULL (PagerFmt), &hfi, M_FORMAT_MAKEPRINT);
-	mutt_paddstr (COLS-SidebarWidth, buffer);
+	mutt_paddstr (statuswidth, buffer);
       }
       else
       {
 	char bn[STRING];
 	snprintf (bn, sizeof (bn), "%s (%s)", banner, pager_progress_str);
-	mutt_paddstr (COLS-SidebarWidth, bn);
+	mutt_paddstr (statuswidth, bn);
       }
+      if(!option(OPTSTATUSONTOP) || PagerIndexLines == 0)
+          DrawFullLine = 0; /* reset */
       BKGDSET (MT_COLOR_NORMAL);
       SETCOLOR (MT_COLOR_NORMAL);
     }
@@ -1828,10 +1838,11 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
       /* print out the index status bar */
       menu_status_line (buffer, sizeof (buffer), index, NONULL(Status));
  
-      move (indexoffset + (option (OPTSTATUSONTOP) ? 0 : (indexlen - 1)), SidebarWidth);
+      move (indexoffset + (option (OPTSTATUSONTOP) ? 0 : (indexlen - 1)),
+          (option(OPTSTATUSONTOP) ? 0: SidebarWidth));
       SETCOLOR (MT_COLOR_STATUS);
       BKGDSET (MT_COLOR_STATUS);
-      mutt_paddstr (COLS-SidebarWidth, buffer);
+      mutt_paddstr (COLS - (option(OPTSTATUSONTOP) ? 0 : SidebarWidth), buffer);
       SETCOLOR (MT_COLOR_NORMAL);
       BKGDSET (MT_COLOR_NORMAL);
     }
diff --git a/sidebar.c b/sidebar.c
index 1e903ef..60bee73 100644
--- a/sidebar.c
+++ b/sidebar.c
@@ -47,6 +47,8 @@ void calc_boundaries (int menu)
 {
 	BUFFY *tmp = Incoming;
 
+	int count = LINES - 2 - (option(OPTHELP) ? 1 : 0);
+
 	if ( known_lines != LINES ) {
 		TopBuffy = BottomBuffy = 0;
 		known_lines = LINES;
@@ -86,13 +88,11 @@ void calc_boundaries (int menu)
 	if ( TopBuffy == 0 && BottomBuffy == 0 )
 		TopBuffy = Incoming;
 	if ( BottomBuffy == 0 ) {
-		int count = LINES - 2 - (menu != MENU_PAGER || option(OPTSTATUSONTOP));
 		BottomBuffy = TopBuffy;
 		while ( --count && BottomBuffy->next )
 			BottomBuffy = BottomBuffy->next;
 	}
 	else if ( TopBuffy == CurBuffy->next ) {
-		int count = LINES - 2 - (menu != MENU_PAGER);
 		BottomBuffy = CurBuffy;
 		tmp = BottomBuffy;
 		while ( --count && tmp->prev)
@@ -100,7 +100,6 @@ void calc_boundaries (int menu)
 		TopBuffy = tmp;
 	}
 	else if ( BottomBuffy == CurBuffy->prev ) {
-		int count = LINES - 2 - (menu != MENU_PAGER);
 		TopBuffy = CurBuffy;
 		tmp = TopBuffy;
 		while ( --count && tmp->next )
@@ -165,8 +164,11 @@ void set_curbuffy(char buf[LONG_STRING])
 
 int draw_sidebar(int menu) {
 
-	int lines = option(OPTHELP) ? 1 : 0;
-    lines += option(OPTSTATUSONTOP) ? 1 : 0;
+	int lines = 0;
+	int SidebarHeight;
+
+	if(option(OPTSTATUSONTOP) || option(OPTHELP))
+		lines++; /* either one will occupy the first line */
 
 	BUFFY *tmp;
 #ifndef USE_SLANG_CURSES
@@ -237,7 +239,11 @@ int draw_sidebar(int menu) {
 
 	/* draw the divider */
 
-	for ( ; lines < LINES-1-(menu != MENU_PAGER || option(OPTSTATUSONTOP)); lines++ ) {
+	SidebarHeight =  LINES - 1;
+	if(option(OPTHELP) || !option(OPTSTATUSONTOP))
+		SidebarHeight--;
+
+	for ( ; lines < SidebarHeight; lines++ ) {
 		move(lines, SidebarWidth - delim_len);
 		addstr(NONULL(SidebarDelim));
 #ifndef USE_SLANG_CURSES
@@ -246,8 +252,9 @@ int draw_sidebar(int menu) {
 	}
 
 	if ( Incoming == 0 ) return 0;
-	lines = option(OPTHELP) ? 1 : 0; /* go back to the top */
-    lines += option(OPTSTATUSONTOP) ? 1 : 0;
+	lines = 0;
+	if(option(OPTSTATUSONTOP) || option(OPTHELP))
+		lines++; /* either one will occupy the first line */
 
 	if ( known_lines != LINES || TopBuffy == 0 || BottomBuffy == 0 ) 
 		calc_boundaries(menu);
@@ -257,7 +264,7 @@ int draw_sidebar(int menu) {
 
 	SETCOLOR(MT_COLOR_NORMAL);
 
-	for ( ; tmp && lines < LINES-1 - (menu != MENU_PAGER || option(OPTSTATUSONTOP)); tmp = tmp->next ) {
+	for ( ; tmp && lines < SidebarHeight; tmp = tmp->next ) {
 		if ( tmp == CurBuffy )
 			SETCOLOR(MT_COLOR_INDICATOR);
 		else if ( tmp->msg_unread > 0 )
@@ -314,7 +321,7 @@ int draw_sidebar(int menu) {
 		lines++;
 	}
 	SETCOLOR(MT_COLOR_NORMAL);
-	for ( ; lines < LINES-1 - (menu != MENU_PAGER || option(OPTSTATUSONTOP)); lines++ ) {
+	for ( ; lines < SidebarHeight; lines++ ) {
 		int i = 0;
 		move( lines, 0 );
 		for ( ; i < SidebarWidth - delim_len; i++ )
-- 
1.7.7.3

From 5b515a14817e4e5048cfcb5fb08c63bc2ac834f4 Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Fri, 28 Oct 2011 15:18:33 +0200
Subject: [PATCH 08/19] Fix setting CurrBuffy when invoking mutt via -f

Previously, calling `mutt -f=test' wouldn't mark the =test mailbox as
"current" in the sidebar.

Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 main.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/main.c b/main.c
index 0952c93..3d6d1f0 100644
--- a/main.c
+++ b/main.c
@@ -1017,6 +1017,7 @@ int main (int argc, char **argv)
     if((Context = mx_open_mailbox (folder, ((flags & M_RO) || option (OPTREADONLY)) ? M_READONLY : 0, NULL))
        || !explicit_folder)
     {
+      set_curbuffy(folder);
       mutt_index_menu ();
       if (Context)
 	FREE (&Context);
-- 
1.7.7.3

From 9a393e586ceb9c84abd6be69877134b3a5e72766 Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Mon, 24 Oct 2011 19:09:29 +0200
Subject: [PATCH 09/19] cache time when sidebar last counted all the mails

This introduces a member `sb_last_checked' to the BUFFY struct. It will
be set by `mh_buffy_update', `buffy_maildir_update' and
`buffy_mbox_update' when they count all the mails.

Mboxes only: `buffy_mbox_update' will not be run unless the condition
"sb_last_checked > mtime of the file" holds. This solves a huge
performance penalty you obtain with big mailboxes. The `mx_open_mailbox'
call with the M_PEEK flag will *reset* mtime and atime to the values
from before. Thus, you cannot rely on "mtime > atime" to check whether
or not to count new mail.

NOTE: There might be ways to optimize MH and Maildir access, too. I'm
not familiar with the formats, though.

Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 buffy.c |   11 ++++++++---
 buffy.h |    1 +
 mh.c    |    3 ++-
 mx.h    |    2 +-
 4 files changed, 12 insertions(+), 5 deletions(-)

diff --git a/buffy.c b/buffy.c
index 5f90a45..3c3d462 100644
--- a/buffy.c
+++ b/buffy.c
@@ -399,6 +399,7 @@ void buffy_maildir_update (BUFFY* mailbox)
     }
   }
 
+  mailbox->sb_last_checked = time(NULL);
   closedir (dirp);
 }
 
@@ -434,16 +435,20 @@ static int buffy_mbox_hasnew (BUFFY* mailbox, struct stat *sb)
 }
 
 /* update message counts for the sidebar */
-void buffy_mbox_update (BUFFY* mailbox)
+void buffy_mbox_update (BUFFY* mailbox, struct stat *sb)
 {
   CONTEXT *ctx = NULL;
 
+  if(mailbox->sb_last_checked > sb->st_mtime && mailbox->msgcount != 0)
+      return; /* no check necessary */
+
   ctx = mx_open_mailbox(mailbox->path, M_READONLY | M_QUIET | M_NOSORT | M_PEEK, NULL);
   if(ctx)
   {
     mailbox->msgcount = ctx->msgcount;
     mailbox->msg_unread = ctx->unread;
     mailbox->msg_flagged = ctx->flagged;
+    mailbox->sb_last_checked = time(NULL);
     mx_close_mailbox(ctx, 0);
   }
 }
@@ -521,7 +526,7 @@ int mutt_buffy_check (int force)
       {
       case M_MBOX:
       case M_MMDF:
-	buffy_mbox_update (tmp);
+	buffy_mbox_update (tmp, &sb);
 	if (buffy_mbox_hasnew (tmp, &sb) > 0)
 	  BuffyCount++;
 	break;
@@ -533,7 +538,7 @@ int mutt_buffy_check (int force)
 	break;
 
       case M_MH:
-	mh_buffy_update (tmp->path, &tmp->msgcount, &tmp->msg_unread, &tmp->msg_flagged);
+	mh_buffy_update (tmp->path, &tmp->msgcount, &tmp->msg_unread, &tmp->msg_flagged, &tmp->sb_last_checked);
 	if ((tmp->new = mh_buffy (tmp->path)) > 0)
 	  BuffyCount++;
 	break;
diff --git a/buffy.h b/buffy.h
index 7ad2ca2..0427301 100644
--- a/buffy.h
+++ b/buffy.h
@@ -34,6 +34,7 @@ typedef struct buffy_t
   short magic;			/* mailbox type */
   short newly_created;		/* mbox or mmdf just popped into existence */
   time_t last_visited;		/* time of last exit from this mailbox */
+  time_t sb_last_checked;      /* time of last buffy check from sidebar */
 }
 BUFFY;
 
diff --git a/mh.c b/mh.c
index 6e52eb4..ecb929b 100644
--- a/mh.c
+++ b/mh.c
@@ -244,7 +244,7 @@ int mh_buffy (const char *path)
   return r;
 }
 
-void mh_buffy_update (const char *path, int *msgcount, int *msg_unread, int *msg_flagged)
+void mh_buffy_update (const char *path, int *msgcount, int *msg_unread, int *msg_flagged, time_t *sb_last_checked)
 {
   int i;
   struct mh_sequences mhs;
@@ -264,6 +264,7 @@ void mh_buffy_update (const char *path, int *msgcount, int *msg_unread, int *msg
     if (mhs_check (&mhs, i) & MH_SEQ_FLAGGED)
       msg_flagged++;
   mhs_free_sequences (&mhs);
+  *sb_last_checked = time(NULL);
 }
 
 static int mh_mkstemp (CONTEXT * dest, FILE ** fp, char **tgt)
diff --git a/mx.h b/mx.h
index d037aa0..a90577d 100644
--- a/mx.h
+++ b/mx.h
@@ -58,7 +58,7 @@ int mh_read_dir (CONTEXT *, const char *);
 int mh_sync_mailbox (CONTEXT *, int *);
 int mh_check_mailbox (CONTEXT *, int *);
 int mh_buffy (const char *);
-void mh_buffy_update (const char *, int *, int *, int *);
+void mh_buffy_update (const char *, int *, int *, int *, time_t *);
 int mh_check_empty (const char *);
 
 int maildir_read_dir (CONTEXT *);
-- 
1.7.7.3

From aed15971b7e05c215fb2277f95640a3b0a8029f5 Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Mon, 24 Oct 2011 19:31:19 +0200
Subject: [PATCH 10/19] only count mail if sidebar is active

if the sidebar is not active, there's no need to count the mail. (The
information will not be used anyway and wastes performance.)

Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 buffy.c |    5 +++++
 mh.c    |    3 +++
 2 files changed, 8 insertions(+), 0 deletions(-)

diff --git a/buffy.c b/buffy.c
index 3c3d462..68f31c3 100644
--- a/buffy.c
+++ b/buffy.c
@@ -348,6 +348,9 @@ void buffy_maildir_update (BUFFY* mailbox)
   struct dirent *de;
   char *p;
 
+  if(!option(OPTSIDEBAR))
+      return;
+
   mailbox->msgcount = 0;
   mailbox->msg_unread = 0;
   mailbox->msg_flagged = 0;
@@ -439,6 +442,8 @@ void buffy_mbox_update (BUFFY* mailbox, struct stat *sb)
 {
   CONTEXT *ctx = NULL;
 
+  if(!option(OPTSIDEBAR))
+      return;
   if(mailbox->sb_last_checked > sb->st_mtime && mailbox->msgcount != 0)
       return; /* no check necessary */
 
diff --git a/mh.c b/mh.c
index ecb929b..c24fc70 100644
--- a/mh.c
+++ b/mh.c
@@ -250,6 +250,9 @@ void mh_buffy_update (const char *path, int *msgcount, int *msg_unread, int *msg
   struct mh_sequences mhs;
   memset (&mhs, 0, sizeof (mhs));
 
+  if(!option(OPTSIDEBAR))
+      return;
+
   if (mh_read_sequences (&mhs, path) < 0)
     return;
 
-- 
1.7.7.3

From 1af305a1ab191a273656e19e7a72db4a45a5cb0f Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Mon, 24 Oct 2011 19:35:43 +0200
Subject: [PATCH 11/19] buffy: check msg_unread if sidebar is active

This will list the mailboxes that have mailbox->msg_unread > 0, instead
of trusting mtime or similar stuff. (The sidebar has the information,
anyway, and this won't allow the status line buffy and the sidebar to be
out of sync.)

NOTE: This will only work for mboxes and Maildirs.

Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 buffy.c |   10 ++++++++++
 1 files changed, 10 insertions(+), 0 deletions(-)

diff --git a/buffy.c b/buffy.c
index 68f31c3..088927f 100644
--- a/buffy.c
+++ b/buffy.c
@@ -297,6 +297,11 @@ static int buffy_maildir_hasnew (BUFFY* mailbox)
 
   snprintf (path, sizeof (path), "%s/new", mailbox->path);
 
+  if (option(OPTSIDEBAR) && mailbox->msg_unread > 0) {
+      mailbox->new = 1;
+      return 1;
+  }
+
   /* when $mail_check_recent is set, if the new/ directory hasn't been modified since
    * the user last exited the mailbox, then we know there is no recent mail.
    */
@@ -434,6 +439,11 @@ static int buffy_mbox_hasnew (BUFFY* mailbox, struct stat *sb)
       (sb->st_ctime != sb->st_mtime || sb->st_ctime != sb->st_atime))
     mailbox->newly_created = 0;
 
+  if (option(OPTSIDEBAR) && mailbox->msg_unread > 0) {
+      mailbox->new = 1;
+      rc = 1;
+  }
+
   return rc;
 }
 
-- 
1.7.7.3

From 3f2e59020dc4bfb61faafc847f7871fa897eaaa2 Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Mon, 24 Oct 2011 19:56:15 +0200
Subject: [PATCH 12/19] fix sidebar and buffy updates

i)  if the sidebar was previously turned off and is toggled on, force
    re-counting of mails.
ii) if mutt_buffy_check() records any new mail, don't necessarily do a
    full redraw
iii) Introduce REDRAW_SIDEBAR to only redraw the sidebar. This is done
    very often, but utilizing REDRAW_FULL for that (as it was done
    previously) leads to flicker effects, although you only have to
    update a simple number.

Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 curs_main.c |    8 +++++++-
 mutt_menu.h |    1 +
 sidebar.c   |    1 +
 3 files changed, 9 insertions(+), 1 deletions(-)

diff --git a/curs_main.c b/curs_main.c
index cd8b0a7..1564f62 100644
--- a/curs_main.c
+++ b/curs_main.c
@@ -523,7 +523,7 @@ int mutt_index_menu (void)
      {
        if (mutt_buffy_notify ())
        {
-         menu->redraw |= REDRAW_FULL;
+         menu->redraw |= REDRAW_STATUS;
          if (option (OPTBEEPNEW))
            beep ();
        }
@@ -532,6 +532,9 @@ int mutt_index_menu (void)
        do_buffy_notify = 1;
     }
 
+    if(option(OPTSIDEBAR))
+        menu->redraw |= REDRAW_SIDEBAR;
+
     if (op != -1)
       mutt_curs_set (0);
 
@@ -540,6 +543,9 @@ int mutt_index_menu (void)
       menu_redraw_full (menu);
       draw_sidebar(menu->menu);
       mutt_show_error ();
+    } else if(menu->redraw & REDRAW_SIDEBAR) {
+        draw_sidebar(menu->menu);
+        menu->redraw &= ~REDRAW_SIDEBAR;
     }
 
     if (menu->menu == MENU_MAIN)
diff --git a/mutt_menu.h b/mutt_menu.h
index 6ca70d7..0f42d95 100644
--- a/mutt_menu.h
+++ b/mutt_menu.h
@@ -34,6 +34,7 @@
 #define REDRAW_FULL		(1<<5)
 #define REDRAW_BODY		(1<<6)
 #define REDRAW_SIGWINCH		(1<<7)
+#define REDRAW_SIDEBAR		(1<<8)
 
 #define M_MODEFMT "-- Mutt: %s"
 
diff --git a/sidebar.c b/sidebar.c
index 60bee73..b316379 100644
--- a/sidebar.c
+++ b/sidebar.c
@@ -195,6 +195,7 @@ int draw_sidebar(int menu) {
                         saveSidebarWidth = SidebarWidth;
                         SidebarWidth = 0;
                 } else if(!prev_show_value && option(OPTSIDEBAR)) {
+                        mutt_buffy_check(1); /* we probably have bad or no numbers */
                         SidebarWidth = saveSidebarWidth;
                 }
                 prev_show_value = option(OPTSIDEBAR);
-- 
1.7.7.3

From 7d7c9a8b8e38eb5147fac4fe0a647671582ab536 Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Wed, 26 Oct 2011 18:34:00 +0200
Subject: [PATCH 13/19] introduce sidebar_format option

This enables a far more flexible approach to customizing the sidebar
format, plus it is a lot cleaner and more consistent with other mutt
options.

Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 globals.h |    1 +
 init.h    |   10 +++++
 protos.h  |    7 +++
 sidebar.c |  130 ++++++++++++++++++++++++++++++++++++++++++-------------------
 4 files changed, 108 insertions(+), 40 deletions(-)

diff --git a/globals.h b/globals.h
index ced77ce..8a207ed 100644
--- a/globals.h
+++ b/globals.h
@@ -118,6 +118,7 @@ WHERE char *SendCharset;
 WHERE char *Sendmail;
 WHERE char *Shell;
 WHERE char *SidebarDelim;
+WHERE char *SidebarFormat;
 WHERE char *Signature;
 WHERE char *SimpleSearch;
 #if USE_SMTP
diff --git a/init.h b/init.h
index 4c81e41..3bad608 100644
--- a/init.h
+++ b/init.h
@@ -1979,6 +1979,16 @@ struct option_t MuttVars[] = {
   ** .pp
   ** Should the sidebar be sorted.
   */
+  {"sidebar_format", DT_STR, R_NONE, UL &SidebarFormat, UL "%B%?F? [%F]?%* %?N?%N/?%4S"},
+  /*
+  ** .pp
+  ** Format string for the sidebar. The sequences `%N', `%F' and `%S'
+  ** will be replaced by the number of new or flagged messages or the total
+  ** size of them mailbox. `%B' will be replaced with the name of the mailbox.
+  ** The `%!' sequence will be expanded to `!' if there is one flagged message;
+  ** to `!!' if there are two flagged messages; and to `n!' for n flagged
+  ** messages, n>2.
+  */
   { "pgp_use_gpg_agent", DT_BOOL, R_NONE, OPTUSEGPGAGENT, 0},
   /*
   ** .pp
diff --git a/protos.h b/protos.h
index 12e4969..b9d18b3 100644
--- a/protos.h
+++ b/protos.h
@@ -36,6 +36,13 @@ struct hdr_format_info
   const char *pager_progress;
 };
 
+struct sidebar_entry {
+    char                box[SHORT_STRING];
+    unsigned int        size;
+    unsigned int        new;
+    unsigned int        flagged;
+};
+
 void mutt_make_string_info (char *, size_t, const char *, struct hdr_format_info *, format_flag);
 
 int mutt_extract_token (BUFFER *, BUFFER *, int);
diff --git a/sidebar.c b/sidebar.c
index b316379..0c8e296 100644
--- a/sidebar.c
+++ b/sidebar.c
@@ -36,16 +36,9 @@ static BUFFY *TopBuffy = 0;
 static BUFFY *BottomBuffy = 0;
 static int known_lines = 0;
 
-static int quick_log10(int n)
-{
-        char string[32];
-        sprintf(string, "%d", n);
-        return strlen(string);
-}
+void calc_boundaries() {
 
-void calc_boundaries (int menu)
-{
-	BUFFY *tmp = Incoming;
+    BUFFY *tmp = Incoming;
 
 	int count = LINES - 2 - (option(OPTHELP) ? 1 : 0);
 
@@ -108,38 +101,95 @@ void calc_boundaries (int menu)
 	}
 }
 
-char *make_sidebar_entry(char *box, int size, int new, int flagged)
+static const char *
+sidebar_format_str (char *dest,
+			size_t destlen,
+			size_t col,
+			char op,
+			const char *src,
+			const char *prefix,
+			const char *ifstring,
+			const char *elsestring,
+			unsigned long data,
+			format_flag flags)
 {
-	static char *entry = 0;
-	char *c;
-	int i = 0;
-	int delim_len = strlen(SidebarDelim);
-
-	c = realloc(entry, SidebarWidth - delim_len + 2);
-	if ( c ) entry = c;
-	entry[SidebarWidth - delim_len + 1] = 0;
-	for (; i < SidebarWidth - delim_len + 1; entry[i++] = ' ' );
-	i = strlen(box);
-	strncpy( entry, box, i < (SidebarWidth - delim_len + 1) ? i : (SidebarWidth - delim_len + 1) );
-
-        if (size == -1)
-                sprintf(entry + SidebarWidth - delim_len - 3, "?");
-        else if ( new ) {
-          if (flagged > 0) {
-              sprintf(
-		        entry + SidebarWidth - delim_len - 5 - quick_log10(size) - quick_log10(new) - quick_log10(flagged),
-		        "% d(%d)[%d]", size, new, flagged);
-          } else {
-              sprintf(
-                      entry + SidebarWidth - delim_len - 3 - quick_log10(size) - quick_log10(new),
-                      "% d(%d)", size, new);
-          }
-        } else if (flagged > 0) {
-              sprintf( entry + SidebarWidth - delim_len - 3 - quick_log10(size) - quick_log10(flagged), "% d[%d]", size, flagged);
-        } else {
-              sprintf( entry + SidebarWidth - delim_len - 1 - quick_log10(size), "% d", size);
-        }
-	return entry;
+/* casting from unsigned long - srsly?! */
+struct sidebar_entry *sbe = (struct sidebar_entry *) data;
+unsigned int optional;
+char fmt[SHORT_STRING], buf[SHORT_STRING];
+
+optional = flags & M_FORMAT_OPTIONAL;
+
+switch(op) {
+	case 'F':
+		if(!optional) {
+			snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
+			snprintf (dest, destlen, fmt, sbe->flagged);
+		} else if(sbe->flagged == 0) {
+			optional = 0;
+		}
+		break;
+
+	case '!':
+		if(sbe->flagged == 0)
+			mutt_format_s(dest, destlen, prefix, "");
+		if(sbe->flagged == 1)
+			mutt_format_s(dest, destlen, prefix, "!");
+		if(sbe->flagged == 2)
+			mutt_format_s(dest, destlen, prefix, "!!");
+		if(sbe->flagged > 2) {
+			snprintf (buf, sizeof (buf), "%d!", sbe->flagged);
+			mutt_format_s(dest, destlen, prefix, buf);
+		}
+		break;
+
+	case 'S':
+		snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
+		snprintf (dest, destlen, fmt, sbe->size);
+		break;
+
+	case 'N':
+		if(!optional) {
+			snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
+			snprintf (dest, destlen, fmt, sbe->new);
+		} else if(sbe->new == 0) {
+			optional = 0;
+		}
+		break;
+
+	case 'B':
+		mutt_format_s(dest, destlen, prefix, sbe->box);
+		break;
+	}
+
+	if(optional)
+		mutt_FormatString (dest, destlen, col, ifstring, sidebar_format_str, (unsigned long) sbe, flags);
+	else if (flags & M_FORMAT_OPTIONAL)
+		mutt_FormatString (dest, destlen, col, elsestring, sidebar_format_str, (unsigned long) sbe, flags);
+
+	return (src);
+}
+
+char *make_sidebar_entry(char *box, unsigned int size, unsigned int new, unsigned int flagged) {
+    static char *entry = 0;
+    struct sidebar_entry sbe;
+    int SBvisual;
+
+    SBvisual = SidebarWidth - strlen(SidebarDelim);
+    if (SBvisual < 1)
+        return NULL;
+
+    sbe.new = new;
+    sbe.flagged = flagged;
+    sbe.size = size;
+    strncpy(sbe.box, box, 31);
+
+    safe_realloc(&entry, SBvisual + 2);
+    entry[SBvisual + 1] = '\0';
+
+    mutt_FormatString (entry, SBvisual+1, 0, SidebarFormat, sidebar_format_str, (unsigned long) &sbe, 0);
+
+    return entry;
 }
 
 void set_curbuffy(char buf[LONG_STRING])
-- 
1.7.7.3

From bd2d73fe668ca3d335e064508474661c9122a4b4 Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Fri, 28 Oct 2011 15:35:28 +0200
Subject: [PATCH 14/19] introduce sidebar_folderindent option

Thus it is possible to disable the (IMHO) completely unnecessary (and
faulty) indentation. Consequently, the option is set to "no" by default.

Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 init.h    |    6 ++++++
 mutt.h    |    1 +
 sidebar.c |    2 +-
 3 files changed, 8 insertions(+), 1 deletions(-)

diff --git a/init.h b/init.h
index 3bad608..df13e98 100644
--- a/init.h
+++ b/init.h
@@ -1989,6 +1989,12 @@ struct option_t MuttVars[] = {
   ** to `!!' if there are two flagged messages; and to `n!' for n flagged
   ** messages, n>2.
   */
+  { "sidebar_folderindent", DT_BOOL, R_BOTH, OPTSIDEBARFOLDERINDENT, 0 },
+  /*
+  ** .pp
+  ** Should folders be indented in the sidebar.
+  */
+
   { "pgp_use_gpg_agent", DT_BOOL, R_NONE, OPTUSEGPGAGENT, 0},
   /*
   ** .pp
diff --git a/mutt.h b/mutt.h
index 0ed1b8e..f598b4a 100644
--- a/mutt.h
+++ b/mutt.h
@@ -422,6 +422,7 @@ enum
   OPTSIDEBAR,
   OPTSIDEBARSHORTPATH,
   OPTSIDEBARSORT,
+  OPTSIDEBARFOLDERINDENT,
   OPTSIGDASHES,
   OPTSIGONTOP,
   OPTSORTRE,
diff --git a/sidebar.c b/sidebar.c
index 0c8e296..9cd6ba3 100644
--- a/sidebar.c
+++ b/sidebar.c
@@ -340,7 +340,7 @@ int draw_sidebar(int menu) {
 		int sidebar_folder_depth = 0;
 		char *sidebar_folder_name;
 		sidebar_folder_name = mutt_basename(tmp->path);
-		if ( maildir_is_prefix ) {
+		if ( maildir_is_prefix && option(OPTSIDEBARFOLDERINDENT) ) {
 			char *tmp_folder_name;
 			int i;
 			tmp_folder_name = tmp->path + strlen(Maildir);
-- 
1.7.7.3

From 3776d7d28624f0761edc5f8d4956af2c62cf1dc1 Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Wed, 5 Oct 2011 18:27:17 +0200
Subject: [PATCH 15/19] keep buffer-like temp file in memory

When searching the header or body for strings and the `thorough_search'
option is set, a temp file was created, parsed, and then unlinked again.
This is now done in memory using glibc's open_memstream() and
fmemopen() if they are available.

This is a bit hackish, but might increase performance greatly. YMMV.

Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 configure.ac |    2 ++
 handler.c    |   29 +++++++++++++++++++++++++++++
 pattern.c    |   38 ++++++++++++++++++++++++++++++++++++++
 3 files changed, 69 insertions(+), 0 deletions(-)

diff --git a/configure.ac b/configure.ac
index 5a8c7f0..91964c1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1289,6 +1289,8 @@ if test $mutt_cv_langinfo_yesexpr = yes; then
   AC_DEFINE(HAVE_LANGINFO_YESEXPR,1,[ Define if you have <langinfo.h> and nl_langinfo(YESEXPR). ])
 fi
 
+AC_CHECK_FUNCS(fmemopen open_memstream)
+
 dnl Documentation tools
 have_openjade="no"
 AC_PATH_PROG([OSPCAT], [ospcat], [none])
diff --git a/handler.c b/handler.c
index a45fbab..13162a1 100644
--- a/handler.c
+++ b/handler.c
@@ -1525,6 +1525,11 @@ int mutt_body_handler (BODY *b, STATE *s)
   char type[STRING];
   int rc = 0;
 
+#ifdef HAVE_FMEMOPEN
+  char *temp;
+  size_t tempsize;
+#endif
+
   int oflags = s->flags;
   
   /* first determine which handler to use to process this part */
@@ -1644,6 +1649,14 @@ int mutt_body_handler (BODY *b, STATE *s)
       {
 	/* decode to a tempfile, saving the original destination */
 	fp = s->fpout;
+#ifdef HAVE_FMEMOPEN
+	if ((s->fpout = open_memstream(&temp, &tempsize)) == NULL)
+	{
+	  mutt_error _("Unable to open memory stream!");
+	  dprint (1, (debugfile, "Can't open memory stream.\n"));
+	  goto bail;
+	}
+#else
 	mutt_mktemp (tempfile, sizeof (tempfile));
 	if ((s->fpout = safe_fopen (tempfile, "w")) == NULL)
 	{
@@ -1651,6 +1664,7 @@ int mutt_body_handler (BODY *b, STATE *s)
 	  dprint (1, (debugfile, "Can't open %s.\n", tempfile));
 	  goto bail;
 	}
+#endif
 	/* decoding the attachment changes the size and offset, so save a copy
 	 * of the "real" values now, and restore them after processing
 	 */
@@ -1679,8 +1693,19 @@ int mutt_body_handler (BODY *b, STATE *s)
 	/* restore final destination and substitute the tempfile for input */
 	s->fpout = fp;
 	fp = s->fpin;
+#ifdef HAVE_FMEMOPEN
+	if(tempsize)
+		s->fpin = fmemopen(temp, tempsize, "r");
+	else /* fmemopen cannot handle zero-length buffers */
+		s->fpin = safe_fopen ("/dev/null", "r");
+	if(s->fpin == NULL) {
+		mutt_perror("failed to re-open memstream!");
+		return (-1);
+	}
+#else
 	s->fpin = fopen (tempfile, "r");
 	unlink (tempfile);
+#endif
 
 	/* restore the prefix */
 	s->prefix = savePrefix;
@@ -1706,6 +1731,10 @@ int mutt_body_handler (BODY *b, STATE *s)
 
 	/* restore the original source stream */
 	safe_fclose (&s->fpin);
+#ifdef HAVE_FMEMOPEN
+	if(tempsize)
+	    FREE(&temp);
+#endif
 	s->fpin = fp;
       }
     }
diff --git a/pattern.c b/pattern.c
index dbd73bd..d9ccfbc 100644
--- a/pattern.c
+++ b/pattern.c
@@ -154,6 +154,10 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
   HEADER *h = ctx->hdrs[msgno];
   char *buf;
   size_t blen;
+#ifdef HAVE_FMEMOPEN
+  char *temp;
+  size_t tempsize;
+#endif
 
   if ((msg = mx_open_message (ctx, msgno)) != NULL)
   {
@@ -163,12 +167,20 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
       memset (&s, 0, sizeof (s));
       s.fpin = msg->fp;
       s.flags = M_CHARCONV;
+#ifdef HAVE_FMEMOPEN
+      if((s.fpout = open_memstream(&temp, &tempsize)) == NULL)
+      {
+	mutt_perror ("Error opening memstream");
+	return (0);
+      }
+#else
       mutt_mktemp (tempfile, sizeof (tempfile));
       if ((s.fpout = safe_fopen (tempfile, "w+")) == NULL)
       {
 	mutt_perror (tempfile);
 	return (0);
       }
+#endif
 
       if (pat->op != M_BODY)
 	mutt_copy_header (msg->fp, h, s.fpout, CH_FROM | CH_DECODE, NULL);
@@ -184,7 +196,11 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
 	  if (s.fpout)
 	  {
 	    safe_fclose (&s.fpout);
+#ifdef HAVE_FMEMOPEN
+            FREE(&temp);
+#else
 	    unlink (tempfile);
+#endif
 	  }
 	  return (0);
 	}
@@ -193,11 +209,28 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
 	mutt_body_handler (h->content, &s);
       }
 
+#ifdef HAVE_FMEMOPEN
+      fclose(s.fpout);
+      lng = tempsize;
+
+      if(tempsize) {
+          if ((fp = fmemopen(temp, tempsize, "r")) == NULL) {
+            mutt_perror ("Error re-opening memstream");
+            return (0);
+          }
+      } else { /* fmemopen cannot handle empty buffers */
+          if ((fp = safe_fopen ("/dev/null", "r")) == NULL) {
+            mutt_perror ("Error opening /dev/null");
+            return (0);
+          }
+      }
+#else
       fp = s.fpout;
       fflush (fp);
       fseek (fp, 0, 0);
       fstat (fileno (fp), &st);
       lng = (long) st.st_size;
+#endif
     }
     else
     {
@@ -244,7 +277,12 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
     if (option (OPTTHOROUGHSRC))
     {
       safe_fclose (&fp);
+#ifdef HAVE_FMEMOPEN
+      if(tempsize)
+          FREE (&temp);
+#else
       unlink (tempfile);
+#endif
     }
   }
 
-- 
1.7.7.3

From 9e862aa5ce37c0be43c6e1108174f45c07230e69 Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Wed, 30 Nov 2011 12:43:52 +0100
Subject: [PATCH 16/19] Bugfix: use realpath() on initial folder

Buffy does this; thus, if you want your ~//INBOX to be the same as
~/INBOX (which it is, of course), you need to realpath() it first.

Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 buffy.c   |    8 ++++++--
 buffy.h   |    1 +
 main.c    |    7 +++++++
 sidebar.c |    5 +++--
 4 files changed, 17 insertions(+), 4 deletions(-)

diff --git a/buffy.c b/buffy.c
index 088927f..fa76a49 100644
--- a/buffy.c
+++ b/buffy.c
@@ -196,9 +196,13 @@ void mutt_update_mailbox (BUFFY * b)
 static BUFFY *buffy_new (const char *path)
 {
   BUFFY* buffy;
+  char rp[PATH_MAX];
+  char *r;
 
   buffy = (BUFFY *) safe_calloc (1, sizeof (BUFFY));
   strfcpy (buffy->path, path, sizeof (buffy->path));
+  r = realpath(path, rp);
+  strfcpy (buffy->realpath, r ? rp : path, sizeof (buffy->realpath));
   buffy->next = NULL;
   buffy->magic = 0;
 
@@ -243,8 +247,8 @@ int mutt_parse_mailboxes (BUFFER *path, BUFFER *s, unsigned long data, BUFFER *e
     p = realpath (buf, f1);
     for (tmp = &Incoming; *tmp; tmp = &((*tmp)->next))
     {
-      q = realpath ((*tmp)->path, f2);
-      if (mutt_strcmp (p ? p : buf, q ? q : (*tmp)->path) == 0)
+      q = (*tmp)->realpath;
+      if (mutt_strcmp (p ? p : buf, q) == 0)
       {
 	dprint(3,(debugfile,"mailbox '%s' already registered as '%s'\n", buf, (*tmp)->path));
 	break;
diff --git a/buffy.h b/buffy.h
index 0427301..8c203e1 100644
--- a/buffy.h
+++ b/buffy.h
@@ -23,6 +23,7 @@
 typedef struct buffy_t
 {
   char path[_POSIX_PATH_MAX];
+  char realpath[_POSIX_PATH_MAX];
   off_t size;
   struct buffy_t *next;
   struct buffy_t *prev;
diff --git a/main.c b/main.c
index 3d6d1f0..9567bdb 100644
--- a/main.c
+++ b/main.c
@@ -995,6 +995,13 @@ int main (int argc, char **argv)
       strfcpy (folder, NONULL(Spoolfile), sizeof (folder));
     mutt_expand_path (folder, sizeof (folder));
 
+    {
+      char tmpfolder[_POSIX_PATH_MAX];
+      strfcpy (tmpfolder, folder, sizeof (tmpfolder));
+      if(!realpath(tmpfolder, folder))
+          strfcpy (folder, tmpfolder, sizeof (tmpfolder));
+    }
+
     mutt_str_replace (&CurrentFolder, folder);
     mutt_str_replace (&LastFolder, folder);
 
diff --git a/sidebar.c b/sidebar.c
index 9cd6ba3..0d8dcf3 100644
--- a/sidebar.c
+++ b/sidebar.c
@@ -200,7 +200,7 @@ void set_curbuffy(char buf[LONG_STRING])
     return;
 
   while(1) {
-    if(!strcmp(tmp->path, buf)) {
+    if(!strcmp(tmp->path, buf) || !strcmp(tmp->realpath, buf)) {
       CurBuffy = tmp;
       break;
     }
@@ -326,7 +326,8 @@ int draw_sidebar(int menu) {
 			SETCOLOR(MT_COLOR_NORMAL);
 
 		move( lines, 0 );
-		if ( Context && !strcmp( tmp->path, Context->path ) ) {
+		if ( Context && (!strcmp(tmp->path, Context->path)||
+				 !strcmp(tmp->realpath, Context->path)) ) {
 			tmp->msg_unread = Context->unread;
 			tmp->msgcount = Context->msgcount;
 			tmp->msg_flagged = Context->flagged;
-- 
1.7.7.3

From c0b440966a6d2af29dd90364f644f39a243cedba Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Wed, 30 Nov 2011 12:55:33 +0100
Subject: [PATCH 17/19] Sidebar: Copy numbers before leaving mailbox

Previously, the sidebar would not honor a change in the number of mails
when some mails were deleted by an implicit sync (ie., by changing to
another mailbox).

Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 mx.c      |    4 ++++
 sidebar.c |    3 ++-
 2 files changed, 6 insertions(+), 1 deletions(-)

diff --git a/mx.c b/mx.c
index 4dc286a..24ffe2e 100644
--- a/mx.c
+++ b/mx.c
@@ -734,6 +734,8 @@ void mx_fastclose_mailbox (CONTEXT *ctx)
   mutt_clear_threads (ctx);
   for (i = 0; i < ctx->msgcount; i++)
     mutt_free_header (&ctx->hdrs[i]);
+  ctx->msgcount -= ctx->deleted;
+  set_buffystats(ctx);
   FREE (&ctx->hdrs);
   FREE (&ctx->v2r);
   FREE (&ctx->path);
@@ -827,6 +829,8 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
     if (!ctx->hdrs[i]->deleted && ctx->hdrs[i]->read 
         && !(ctx->hdrs[i]->flagged && option (OPTKEEPFLAGGED)))
       read_msgs++;
+    if (ctx->hdrs[i]->deleted && !ctx->hdrs[i]->read)
+      ctx->unread--;
   }
 
   if (read_msgs && quadoption (OPT_MOVE) != M_NO)
diff --git a/sidebar.c b/sidebar.c
index 0d8dcf3..4ce9097 100644
--- a/sidebar.c
+++ b/sidebar.c
@@ -387,7 +387,8 @@ void set_buffystats(CONTEXT* Context)
 {
         BUFFY *tmp = Incoming;
         while(tmp) {
-                if(Context && !strcmp(tmp->path, Context->path)) {
+                if(Context && (!strcmp(tmp->path, Context->path) ||
+                               !strcmp(tmp->realpath, Context->path))) {
 			tmp->msg_unread = Context->unread;
 			tmp->msgcount = Context->msgcount;
                         break;
-- 
1.7.7.3

From e0565fb7c303acebc0761111b06d63cf7166781b Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Wed, 30 Nov 2011 14:25:31 +0100
Subject: [PATCH 18/19] Fix Buffy/Sidebar and mail_check_recent issues


Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 buffy.c |   17 ++++++-----------
 mx.c    |    3 ++-
 2 files changed, 8 insertions(+), 12 deletions(-)

diff --git a/buffy.c b/buffy.c
index fa76a49..e58d4f1 100644
--- a/buffy.c
+++ b/buffy.c
@@ -301,11 +301,6 @@ static int buffy_maildir_hasnew (BUFFY* mailbox)
 
   snprintf (path, sizeof (path), "%s/new", mailbox->path);
 
-  if (option(OPTSIDEBAR) && mailbox->msg_unread > 0) {
-      mailbox->new = 1;
-      return 1;
-  }
-
   /* when $mail_check_recent is set, if the new/ directory hasn't been modified since
    * the user last exited the mailbox, then we know there is no recent mail.
    */
@@ -315,6 +310,11 @@ static int buffy_maildir_hasnew (BUFFY* mailbox)
       return 0;
   }
 
+  if (option(OPTSIDEBAR) && mailbox->msg_unread > 0) {
+      mailbox->new = 1;
+      return 1;
+  }
+
   if ((dirp = opendir (path)) == NULL)
   {
     mailbox->magic = 0;
@@ -426,7 +426,7 @@ static int buffy_mbox_hasnew (BUFFY* mailbox, struct stat *sb)
   else
     statcheck = sb->st_mtime > sb->st_atime
       || (mailbox->newly_created && sb->st_ctime == sb->st_mtime && sb->st_ctime == sb->st_atime);
-  if (statcheck)
+  if ((!option(OPTSIDEBAR) && statcheck) || (option(OPTSIDEBAR) && mailbox->msg_unread > 0))
   {
     if (!option(OPTMAILCHECKRECENT) || sb->st_mtime > mailbox->last_visited)
     {
@@ -443,11 +443,6 @@ static int buffy_mbox_hasnew (BUFFY* mailbox, struct stat *sb)
       (sb->st_ctime != sb->st_mtime || sb->st_ctime != sb->st_atime))
     mailbox->newly_created = 0;
 
-  if (option(OPTSIDEBAR) && mailbox->msg_unread > 0) {
-      mailbox->new = 1;
-      rc = 1;
-  }
-
   return rc;
 }
 
diff --git a/mx.c b/mx.c
index 24ffe2e..6903559 100644
--- a/mx.c
+++ b/mx.c
@@ -722,7 +722,8 @@ void mx_fastclose_mailbox (CONTEXT *ctx)
 
   /* never announce that a mailbox we've just left has new mail. #3290
    * XXX: really belongs in mx_close_mailbox, but this is a nice hook point */
-  mutt_buffy_setnotified(ctx->path);
+  if(!ctx->peekonly)
+    mutt_buffy_setnotified(ctx->path);
 
   if (ctx->mx_close)
     ctx->mx_close (ctx);
-- 
1.7.7.3

From e34bbcbaf7e1fd89bb49f9b3b2a481d2497ea5ca Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Fri, 6 Jan 2012 15:36:03 +0100
Subject: [PATCH 19/19] Copy number of flagged messages when leaving mbox


Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 mx.c      |    2 ++
 sidebar.c |    1 +
 2 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/mx.c b/mx.c
index 6903559..6189e71 100644
--- a/mx.c
+++ b/mx.c
@@ -832,6 +832,8 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
       read_msgs++;
     if (ctx->hdrs[i]->deleted && !ctx->hdrs[i]->read)
       ctx->unread--;
+    if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->flagged)
+      ctx->flagged--;
   }
 
   if (read_msgs && quadoption (OPT_MOVE) != M_NO)
diff --git a/sidebar.c b/sidebar.c
index 4ce9097..83ec2c2 100644
--- a/sidebar.c
+++ b/sidebar.c
@@ -391,6 +391,7 @@ void set_buffystats(CONTEXT* Context)
                                !strcmp(tmp->realpath, Context->path))) {
 			tmp->msg_unread = Context->unread;
 			tmp->msgcount = Context->msgcount;
+			tmp->msg_flagged = Context->flagged;
                         break;
                 }
                 tmp = tmp->next;
-- 
1.7.7.3

From 2c58c201e1a6d0f24ba20e9b105cb04f60a56d87 Mon Sep 17 00:00:00 2001
From: Julius Plenz <plenz@cis.fu-berlin.de>
Date: Thu, 19 Jan 2012 13:33:49 +0100
Subject: [PATCH] use PATH_MAX instead of _POSIX_PATH_MAX when realpath()ing

From realpath(2):

    Otherwise, if PATH_MAX is defined as a constant in the <limits.h>
    header, then the generated pathname shall be stored as a
    null-terminated string, up to a maximum of PATH_MAX bytes, in the
    buffer pointed to by resolved_name.

PATH_MAX is required to be at least as big as _POSIX_PATH_MAX (= 255).
Usually, PATH_MAX = 4096, however.

Thanks to Jakob Matthes, who noticed that mutt would crash when compiled
with _FORTIFY_SOURCE=2.

Signed-off-by: Julius Plenz <plenz@cis.fu-berlin.de>
---
 main.c |    5 +++--
 1 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/main.c b/main.c
index 9567bdb..9543506 100644
--- a/main.c
+++ b/main.c
@@ -50,6 +50,7 @@
 #include <unistd.h>
 #include <errno.h>
 #include <sys/stat.h>
+#include <limits.h>
 #include <sys/utsname.h>
 
 #ifdef HAVE_GETOPT_H
@@ -525,7 +526,7 @@ init_extended_keys();
 
 int main (int argc, char **argv)
 {
-  char folder[_POSIX_PATH_MAX] = "";
+  char folder[PATH_MAX] = "";
   char *subject = NULL;
   char *includeFile = NULL;
   char *draftFile = NULL;
@@ -996,7 +997,7 @@ int main (int argc, char **argv)
     mutt_expand_path (folder, sizeof (folder));
 
     {
-      char tmpfolder[_POSIX_PATH_MAX];
+      char tmpfolder[PATH_MAX];
       strfcpy (tmpfolder, folder, sizeof (tmpfolder));
       if(!realpath(tmpfolder, folder))
           strfcpy (folder, tmpfolder, sizeof (tmpfolder));
-- 
1.7.7.3-zedat

From 2f0a5ad21ca0f98bda8be04abb5a55a2250709ba Mon Sep 17 00:00:00 2001
From: Robin Randhawa <robin.randhawa@gmail.com>
Date: Sat, 16 Jun 2012 00:13:35 +0100
Subject: [PATCH] Remove outdated AM_C_PROTOTYPES from configure.ac.

---
 configure.ac |    1 -
 1 file changed, 1 deletion(-)

diff --git a/configure.ac b/configure.ac
index 91964c1..1fad113 100644
--- a/configure.ac
+++ b/configure.ac
@@ -27,7 +27,6 @@ AC_MSG_RESULT($mutt_cv_prefix)
 
 AC_PROG_CC
 AC_ISC_POSIX
-AM_C_PROTOTYPES
 if test "x$U" != "x"; then
   AC_MSG_ERROR(Compiler not ANSI compliant)
 fi
-- 
1.7.10.2

